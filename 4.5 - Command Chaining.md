---
course: Dynamous Agentic Coding
module: 4
lesson: "4.5"
title: "Command Chaining"
type: lecture
status: raw
date_added: 2026-02-18
date_modified: 2026-02-18
tags:
  - dynamous
  - agentic-coding
  - module-4-commands
  - command-chaining
  - workflow-automation
key_concepts: []
prerequisites: ["4.1", "4.2", "4.3", "4.4"]
related_lessons: ["5.1"]
---


Welcome to the bonus video for the commands module. This

00:03

is all about command chaining. I'm gonna give you a

00:06

live example, chaining

00:08

all of our core commands together. So we can do

00:10

a single feature implementation in a single shot with priming,

00:14

planning, executing, and committing with no human in the loop.

00:18

Now, of course, I recommend human in the loop, but

00:20

I'm just giving you a little glimpse into what we'll

00:23

get to in future modules when we really trust our

00:25

workflow to knock things out end to end. And so

00:28

when we really start to get into automating our systems,

00:31

I'll cover command chaining a lot more. But I wanna

00:35

cover it here just as a quick bonus video because

00:37

it is really pertinent to everything we've been covering and

00:40

the core principles that I've been laying out for you

00:42

in this module,

00:44

especially the progression

00:45

of complexity that I've been talking about. Like I said,

00:48

we're getting increasingly more autonomous

00:51

with our system

00:52

in this course, starting with manual prompting, going into creating

00:56

our commands or reusable prompts, and then getting into chaining

00:59

things and automating our workflow. And at every step of

01:02

the way, we graduate once we have trust in our

01:05

current process. So we manually prompt until we trust our

01:09

prompting, and then we want to turn into reusable prompts.

01:12

And then we work with that 10, 50, whatever times

01:14

until we get to the point where like, okay,

01:16

our system is so evolved like we've iterated on it

01:18

so much that we can trust it now to knock

01:20

things out end to end. That's when we get into

01:22

command chaining. So I am just giving you a sneak

01:25

peek here for what we have coming soon. And so

01:28

I have all of the core commands

01:30

in the folder for this video here.

01:32

Our prime, plan, execute, and commit. And now the higher

01:35

level command that I'm demoing for you in this video

01:38

is this 1, end to end feature. And it's a

01:40

pretty short and sweet

01:42

command overall because all it's doing here is providing meta

01:46

instructions for how to

01:48

combine all of these commands in a single shot, 1

01:51

workflow. So we start with the prime, load the code

01:54

base context, and then after that, we're gonna create our

01:57

detailed plan of attack for knocking out this feature implementation

02:00

that we specify as the arguments. And so for each

02:03

1 of these commands, I'm just telling it to when

02:05

you get to that step, read that file and then

02:08

use those instructions. It's very similar to how we use

02:10

commands with a coding assistant other than cloud code that

02:14

doesn't support commands directly. Right? Like, we're just telling it

02:16

to look at the file and then assume those instructions.

02:18

And then here is what you want to give for

02:21

the arguments. Right? Like, we're just taking our feature description

02:23

and then telling it to replace the arguments in that

02:26

markdown document with that.

02:28

Then after we create our structure plan, then we're going

02:31

to read that and pass that in to execute. And

02:33

then finally, we're gonna commit and save our changes. And

02:36

then we're just giving a final summary at the end.

02:38

That's the output part of the structure we have for

02:40

our command.

02:41

So really it's our input

02:43

and then it is our process

02:45

and then it is our output. Very, very simple. And

02:48

so I'm gonna take this and then our core commands.

02:51

I'm gonna put that into our Obsidian AI agent, and

02:54

then let's watch it implement a feature end to end.

02:57

Alright. Here we are in the repo for the Obsidian

02:59

AI agent, and

03:01

I wiped the commands folder and just pasted in the

03:03

core commands and this new end to end feature command.

03:05

This is what we're about to implement here. And let

03:08

me be very clear, I'm not telling you to always

03:11

try to work to the point where you can do

03:13

these things end to end. Especially for more complex features,

03:16

you always still wanna be in the loop. But there

03:18

is a time and place to automate these things. And

03:21

when I cover more

03:23

about prompt chaining in future modules, I'll also talk about

03:26

how we can kinda chain prompts but still put ourselves

03:29

in the loop so we don't have to manually execute

03:31

the next prompt when we are ready. So more on

03:33

that later, but this is still really cool to demo

03:35

here. And so I'm going to just as a simple

03:38

demo, implement web search into

03:40

our agent. It's the exact same implementation as we did

03:43

in module 2. I just have that stashed away in

03:45

a different folder so we can reimplement it, but this

03:48

time we are prompting

03:49

absolutely nothing. We just have to invoke this command. So

03:52

take a look at how simple this really is. I'm

03:55

kicking off Claude again, and then I'll say slash end

03:58

to end feature, and now I just have to give

04:00

in quotes here a description of what I wanna build.

04:02

So I wanna say, build a web search tool for

04:06

our Obsidian

04:08

AI agent. Boom. There we go. Single sentence. Might wanna

04:11

be more descriptive for a real use case, but this

04:14

is gonna be fun. Just see what it does. Gonna

04:16

Gonna give it a single sentence and have it just

04:18

completely

04:19

run with it. And so this is a pretty fast

04:22

video overall because there's not really much to show you

04:25

step by step since I'm just letting it go with

04:28

it entirely. And so I'm sending in the request. I'll

04:31

pause and come back once it goes through the entire

04:33

workflow,

04:34

and I'll just give you a quick summary of what

04:36

it did. Alright. About 5 minutes later, we have reached

04:39

the end of our workflow. You can see that it's

04:42

saying I can do a git push now, which is

04:44

that last instruction it's supposed to give at the end

04:46

of the commit command.

04:48

And take a look at this. It is a very

04:50

extensive conversation

04:52

because it starts with reading all of the core files

04:55

to prime itself

04:56

and says, yep. Good. Now I have enough context. Let

04:58

me complete the prime step, mark it as complete, and

05:01

then move on to the planning. And then it creates

05:03

our structured plan, which I also inserted something to keep

05:06

it simple by the way because I just wanted this

05:08

to go faster. But, yeah, it creates the structured plan.

05:11

And then we have our plan. Where do we have

05:13

this? It said it put it in plans web search

05:15

tool. So plans web search tool. Cool. So we can

05:18

even look at the artifact afterwards to see for this

05:20

step specifically

05:22

what did it produce. And by the way, this is

05:24

how we're gonna be able to do a bit more

05:25

of human in the loop when we are automating our

05:28

workflows more in the future is with these kinds of

05:30

markdown documents. And so more on that later, but, yeah,

05:33

that's pretty much all that I wanted to show here

05:36

is how we have this fully end to end implementation.

05:38

You can see it going through the testing here within

05:40

the implementation phase. And then finally, we go to the

05:44

committing. And so now it's running all of our git

05:46

commands here. And then we get our summary at the

05:48

end. So this is just beautiful. Just, again, a little

05:52

bit of a teaser for what we're gonna be able

05:54

to do when we really have a system that we

05:57

have evolved and that we trust and we want to

05:59

knock things out like this. Maybe even doing it in

06:02

a remote way, like, from our phone. That's another spoiler

06:06

for what we have coming. So, yeah, with that, that's

06:08

everything that I got for you for this bonus video.

06:10

A lot more on command chaining coming soon. And now

06:13

it is time for the next module. We're gonna dive

06:16

very deep into

06:18

the planning part of the PIV loop. And so I'm

06:20

gonna show you what it looks like to do layer

06:22

1 and layer 2 planning

06:25

for a new feature in our Obsidian AI agent. So

06:27

I'll see you in the next module for that.