---
course: Dynamous Agentic Coding
module: 4
lesson: "4.1"
title: "The Fundamentals of Commands"
type: lecture
status: raw
date_added: 2026-02-18
date_modified: 2026-02-18
tags:
  - dynamous
  - agentic-coding
  - module-4-commands
  - slash-commands
  - reusable-prompts
key_concepts: []
prerequisites: ["3.4"]
related_lessons: ["4.2", "4.3"]
---


Welcome to module 4 of the DynaMesh agentic coding course.

00:04

This module is dedicated entirely to commands or reusable prompts

00:08

because commands plus your global rules and the rest of

00:11

your layer 1 planning really is the foundation

00:14

for any system you'll create for for working with your

00:16

coding agents. And there's a lot that I have in

00:19

store for you for this module. I'm really excited for

00:21

this because commands are super important. And so in this

00:24

video, I'll start by explaining what commands are and how

00:27

they work. And then in the next couple of videos,

00:29

I'll introduce you to the primary mental model for how

00:32

to structure any command. And then we'll go through all

00:35

the common ones that you're gonna want to use yourself

00:38

that we'll be using for all of our systems in

00:40

the rest of this course. And then at the end,

00:42

I've got an exercise for you to build a couple

00:45

of your own commands.

00:47

Because all of the commands that I have for you

00:49

in this module, it's a great starting point, but you're

00:52

always gonna get the best results when you tune the

00:54

commands to your own use case

00:57

just like with global rules. We covered that same principle

01:00

in the last module. So at the highest level possible,

01:03

commands are simply packaged up processes that define our repeatable

01:08

workflows. When you find yourself prompting something over and over

01:10

again, you don't wanna type it out every time. We

01:12

want to turn it into a file that we can

01:14

then call upon

01:16

as our command. That's exactly what reusable prompts are. And

01:19

they're very similar to global rules because commands are simply

01:23

a markdown document.

01:24

But the key differentiator

01:26

is global rules are for principles and architecture,

01:30

while your commands, your reusable prompts, are for

01:34

processes. And I mentioned that once in module 3, but

01:36

I wanna repeat that again because this is the golden

01:38

standard that helps you figure out what should I put

01:40

in my rules versus what should I put in our

01:43

commands.

01:44

And so this is a very basic example

01:46

that I have for you for what a command looks

01:49

like. And by the way, this structure, right, outline input

01:52

process and output, that's we're gonna talk about in the

01:54

next video for how to structure our commands very efficiently.

01:58

But at a high level, I'm describing

02:01

some of the top level context for the task or

02:03

the process I have for the coding assistant.

02:06

I outline the step by step that I want it

02:08

to do, and then I also specify how I want

02:11

it to report back to me the results of its

02:13

research, implementation,

02:14

whatever the command is doing for me.

02:17

And so now instead of having to type all of

02:19

this out, like this is a command for reviewing code.

02:23

So instead of having to type all this out, now

02:25

I can just call upon this command and there's also

02:28

ways to customize it with parameters and things we'll talk

02:31

about in a little bit. And so now we have

02:33

this workflow that is reusable. It is a beautiful thing.

02:37

And so in Cloud Code, we have this as a

02:39

markdown document in a specific folder. I'll show you this

02:42

in action in a second. And so now literally to

02:45

invoke this entire prompt, all we have to do is

02:47

slash review code, and it'll call upon the instruction set

02:51

that we have here. And then for other AI coding

02:54

assistants that don't support this notion of a slash command,

02:58

all we have to do is just prompt our AI

03:00

coding assistant, read the process in the markdown file for

03:03

our reusable prompt, and execute the instructions now. And so

03:07

the whole idea of commands, it's a little bit nicer

03:10

when you're using a tool like Cloud Code that supports

03:12

this kind of syntax, but this still does apply no

03:15

matter the coding assistant you are using. So with that,

03:17

let's see this in action really quick. Then we'll go

03:19

back to the Excalidraw diagram and then back here to

03:22

finish things off because I got a couple of other

03:24

commands that I wanna show you as examples. But the

03:27

first 1 that I want to use just to show

03:30

you a command in action is the example that we

03:33

saw from our Excalidraw

03:35

diagrams. This is our command for reviewing code. So I'm

03:37

going to copy this and then I'm gonna go into

03:40

that sort of scratch directory that we used in the

03:42

last module for creating our rules with the help of

03:45

encoding assistant.

03:47

And so in cloud code specifically,

03:50

the way that you set up your commands is you

03:52

create a new folder called dot cloud, and this is

03:55

where you also put things like sub agents and skills

03:57

that we'll get into later in this course. And then

04:00

you create a folder called the commands.

04:02

And then within here, any markdown document that we put,

04:05

when we have a new Cloud Code session, it's automatically

04:08

gonna load these as prompts that we can call upon

04:11

with slash review dash code, for example. So I'm gonna

04:14

create a new file and I call it review dash

04:17

code dot m d and then paste in our command

04:20

here. So take a look at this. If I go

04:22

into my terminal now and I start up Claude, which

04:24

by the way you do have to start a new

04:26

session to incorporate new commands that you add. Now I

04:29

can do dash or slash review dash code and boom.

04:32

Send this off and it's going to run that whole

04:35

process that we have outlined right here, which I don't

04:37

have any code for it to review. So I'm just

04:39

gonna go ahead and cut this short here, but you

04:42

get the idea. Right? Like, we have this full process

04:44

as a command that now we don't have to type

04:47

anything out besides slash review code and we're off to

04:50

this races. It's really beautiful because now when we want

04:53

to iterate on this process, we just have to edit

04:55

this file and then every time we call review code

04:58

going forward, it's gonna have that updated process instead of

05:01

us having to remember how we want to prompt things

05:04

over time. So very, very nice. And going back to

05:07

the the Excalidraw here, we can also put it in

05:11

our global dot cloud folder just like our global rule.

05:13

So it's the same kind of thing where it can

05:15

be within our code base. So these commands are project

05:18

specific or it can be global. And the last thing

05:20

that I want to show you an example of really

05:22

quickly is what it looks like if we're using an

05:25

AI coding assistant that doesn't support slash commands directly.

05:29

Because you can't always do slash review code in something

05:32

like GitHub Copilot or Windsurf.

05:35

And so all you have to do is just say

05:38

reference, and then I can call out the path here

05:40

dot cloud slash command slash review dash code, or you

05:43

could put this literally anywhere that you want and take

05:46

on those instructions

05:48

immediately or execute those instructions immediately. I mean, the prompt

05:51

doesn't have to be exactly this. You're just telling it

05:54

to look here and then use it as its prompt.

05:57

So you still don't have to type it out yourself.

05:58

It's not quite as convenient

06:00

as doing slash review code because it also has to

06:03

read the file first, but we're getting the exact same

06:05

functionality. So again, slash commands work no matter the coding

06:09

assistant that you are using. So that is commands in

06:12

just a couple of minutes. It really is simple to

06:14

get started with them. But there's a lot more that

06:17

we can do, especially in making our commands dynamic or

06:20

customizing their behavior

06:22

per execution. So I wanna talk about that right now

06:24

starting with arguments. This is 1 of the most important

06:28

things to understand

06:29

when it comes to using commands

06:31

because we can make them dynamic through parameters. These are

06:34

arguments that we specify

06:36

when we invoke the command. Very similar to arguments we

06:39

might give to a bash script or a Python script

06:42

or a PowerShell script. And so for example, let's say

06:45

we have a command

06:47

for fixing an issue. It's some sort of process we

06:50

have mapped out in this reusable prompt where we're giving

06:53

the coding assistant step by step instructions for how to

06:55

go to GitHub and read an issue, do some sort

06:57

of root cause analysis, and then implement a fix just

07:00

as an example here.

07:03

And so if we just have like a 1 liner

07:05

to illustrate arguments here, let's say fix the issue dollar

07:08

sign arguments following our coding standards. This is the keyword

07:13

in the cloud code specifically where any kind of arguments

07:16

that we specify

07:18

after the call to the command itself, that is going

07:20

to replace what we have for dollar sign arguments. So

07:24

dollar sign arguments

07:25

becomes 1, 2, 3 high priority.

07:28

And so no matter what we specify or if if

07:30

it's 5 parameters, if it's just 1, whatever, that's all

07:33

gonna be replacing dollar sign arguments. And then another thing

07:37

we can do in cloud code, if we want to

07:39

leverage the arguments in different parts of the prompt, is

07:42

we can call out the number for the argument. So

07:45

like 4 5 6 replaces dollar sign 1,

07:49

high replaces dollar sign 2, and Alice replaces dollar sign

07:51

3. And so what this prompt becomes when we invoke

07:54

it this way is review pull request number 4 5

07:57

6 with priority high and assign it to Alice. So

08:01

these are really basic examples. Obviously, this command is gonna

08:04

be pretty elaborate and quite a few steps that we're

08:07

gonna guide the coding assistant through, but I just wanna

08:09

illustrate arguments here and how those work. And then, of

08:13

course, for AI coding assistants that don't support slash commands,

08:16

so we don't have this, like, auto replacing dollar sign

08:19

1 or auto replacing dollar sign arguments, we still can

08:22

use the same functionality

08:24

because I want to keep telling you how this applies

08:26

no matter the coding assistant. Basically, you can just prompt

08:29

it kind of like this. So, like, read the process

08:30

in review p r dot m d and execute the

08:33

instructions now, just like I showed you live a little

08:36

bit ago. And then you just specify, like, for the

08:38

arguments, dollar sign 1 is 4 5 6, dollar sign

08:40

2 is high, 3 is Alice. Right? And then the

08:42

coding assistant, it is intelligent enough to know to, like,

08:45

inject those,

08:47

in the places that it needs to. And so you

08:48

get the exact same functionality

08:50

making these commands dynamic through parameters. Alright. So back over

08:54

to our repo because we have a couple slash commands

08:56

here that I want to show you to illustrate some

08:59

of the different cool things we can do. And so

09:01

we already covered the command example, and then the fix

09:04

issue is what I was showing in the Excalidraw because

09:06

the parameters is the main thing that I wanted to

09:08

demonstrate. That's what applies no matter your coding assistant. The

09:11

next couple of things are a bit more specific to

09:13

cloud code, but I wanna highlight them quickly because that

09:16

is our primary coding assistant in this course. But, yeah,

09:19

here's the fixed issue. It's pretty much just what we

09:21

saw in Excalidraw.

09:23

The next 1 that I have for you, I wanna

09:24

talk about how we can run commands automatically. So right

09:28

when we invoke a command,

09:31

sometimes there's some extra context we want to bring in

09:34

through invoking a bash command. And so I'll give you

09:37

an example.

09:38

For this right here, we have a command that helps

09:41

us create a commit in git or a save state

09:44

in git. And so it's a process that we're giving

09:46

to our coding assistant,

09:48

and what we could do is just, you know, like

09:50

step 1 is execute git status,

09:53

and then step 2 is execute git dev head, and

09:56

then step 3 is make your commit, you know, whatever

09:59

that might be. That's fine, but we're relying on the

10:01

AI coding assistant

10:03

to specify itself when it wants to run these commands.

10:07

And this is definitely gonna work for a really short

10:09

command here, but when we have a really long process,

10:12

it gets a little bit more non deterministic. And so

10:14

maybe we wanna have these commands run automatically so that

10:17

it's going to run git status and then inject this

10:20

as context right into our command when we execute it.

10:23

That's what we can do with the exclamation mark here.

10:25

So it's just exclamation mark and then the command we

10:28

want to run, the bash command that we want to

10:29

run. And then just make sure that these are in

10:32

our list of allowed tools, which is this is another

10:34

little golden nugget of something you can do in cloud

10:37

code specifically.

10:38

You have this kind of YAML front matter here,

10:41

similar to sub agents if you work with sub agents

10:43

where we can specify the tools that it's allowed to

10:46

use. And so that's for security reasons a way that

10:49

you can just control

10:50

the capabilities that your coding assistant has while it is

10:53

operating on this reusable prompt in particular. And then the

10:57

last thing that I wanna highlight, and this is actually

10:59

big because this goes back to our layer 1 planning.

11:03

I was telling you in module 3 that you can

11:06

reference your on demand context in your global rules, but

11:09

it's actually better as a part of your workflow

11:12

to call upon your layer 1 context, like our guide

11:16

to creating tools for our agent, for example, and the

11:19

principles that we wanna follow for this task type. And

11:22

so this is where I get to actually show you

11:24

that in action now. And so I have this command

11:27

called create tool. And, obviously, for a real implementation of

11:31

a plan to create tools in our agent, this would

11:33

be many, many lines long, and it would outline a

11:36

lot more of an elaborate process. But just for demonstration

11:39

purposes here, I wanna show you that we have arguments

11:41

just like our fix issue.

11:43

So we're creating a tool for and then in the

11:45

arguments, we specify the specific tool we want to build.

11:48

So we're making this create tool dynamic to the tool

11:51

we are interested in creating right now. And take a

11:54

look at this. I am referencing the guide that we

11:57

have in the reference folder. And when you do an

12:00

at like this with cloud code slash commands, it's going

12:04

to automatically

12:05

load this markdown document and inject it right into the

12:08

command as context. And then if you're using any other

12:10

AI coding assistant, it's not gonna do that automatically, but

12:13

it's gonna get the same idea that the at means

12:15

that we should read the file, and then it'll go

12:17

and read the file. And so I'll even show you

12:20

that in action here. I'll go to our little scratch

12:22

directory again where I have our create tool command already

12:25

added. And so I'll go into Claude again, and I

12:30

will call the slash create tool command. And take a

12:32

look at this slash create tool, and right here is

12:35

going to automatically take a look at that. It didn't

12:38

even have to think to do this. It did it

12:40

right away. It read the adding tools guide from reference.

12:44

And so I didn't specify the parameter here. That's why

12:47

it's asking me to describe the tool I want, but

12:48

also I could have done create tool and I could

12:50

say a tool to manage folders in our Obsidian vault,

12:55

just like I did as that first example, the PIV

12:58

loop in module 2. Right? So this command

13:00

was basically kicking off the implementation

13:03

that we manually prompted in module 2. So that's the

13:06

beautiful part about commands that I'm gonna be introducing you

13:09

to in this module is that's how we start to

13:11

create our system. We're no longer manually prompting like I

13:15

showed you in module 2. We're now starting to create

13:18

these commands that we're going to call 1 by 1

13:21

to do our planning, to do our implementing, to do

13:24

our validating. We can even chain those together, which is

13:27

definitely a spoiler for what's coming next, but that is

13:29

coming very soon. So last thing that I wanna say

13:31

really quickly here. I hope it makes sense why we're

13:34

splitting out the tool guide and not just including that

13:37

right within the prompt that we have for the command

13:39

so that we have it in a separate file that

13:41

we're calling upon. And the the reason for that is

13:44

because like the global rules, and this is really all

13:46

of layer 1 planning, it's all about the principles and

13:49

architecture. This guide is not a step by step.

13:53

It is principles

13:55

around how to build these tools. Like, what should the

13:57

docstrings look like? And so it's the on demand context

14:01

similar to global rules being auto loading context that we

14:03

want to have as the principles and then the command

14:07

is when we have the process. And so that's why

14:10

I covered global rules and on demand context in the

14:12

last module because our commands build on top of that

14:15

by referencing our on demand context all the time. We're

14:18

gonna see this a lot throughout the course. I really

14:21

wanted to put some emphasis on that here. Cool. So

14:23

we got pretty tactical there, and I did wanna cover

14:26

the nitty gritty details of commands because

14:29

they are so powerful, and they're gonna be the core

14:31

of all of our systems going forward. And so the

14:34

last thing that I wanna cover with you, and I

14:36

hope that this is pretty obvious at this point, but

14:38

I still wanna be on the same page, is why

14:40

we care about using commands in the first place. And

14:43

the golden rule that I have for you here is

14:45

that when you find yourself typing something more than 3

14:48

times, that should scream to you that it should be

14:51

a command. Right? Like, we want to avoid the re

14:54

prompting text. Just like we have

14:57

the context loading text for global rules, it's a similar

15:00

idea with our commands. When we're typing something that much,

15:04

it should clearly be a part of our system. And

15:07

a lot of the things that we did in module

15:08

2 when we were first going over the PIV loop,

15:11

those should have been commands as well.

15:13

I purposely manually prompted things because I wanna get progressively

15:17

more systematized throughout this course.

15:20

But a lot of those things like creating our structure

15:22

plan, asking our coding assistant to execute on it task

15:25

by task, those should all be commands. And we're gonna

15:28

cover that in a couple of videos from now as

15:30

well for even those specific things. And really, most of

15:34

your requests to a coding assistant, you can make a

15:36

command. Every part of your development life cycle. Like, if

15:39

you're asking it to review code for bugs, create a

15:42

commit like a save state, explain code to you, analyze

15:45

for test coverage, implement something task by task. Like, I'm

15:48

giving you examples from every stage of the development life

15:51

cycle because you're gonna find yourself typing a lot of

15:53

these things repeatedly and you can make them all commands.

15:57

And by the time we get towards the end of

15:59

our course here, we're we're not gonna be manually prompting

16:02

most things. We're gonna have a system for committing changes,

16:05

part of our system for implementing and planning. It's all

16:08

gonna be commands because there is a hidden cost to

16:11

1 off prompting basically anything. I'm not trying to say

16:15

you should have a command for 100 percent of things,

16:18

like when you're doing little error fixes and things like

16:20

that, but most things you should because when you have

16:23

your commands as a part of your system, you are

16:26

able to evolve your system. Right? That's 1 of the

16:28

core principles that I introduced in module 1 is that

16:31

every mistake your coding assistant makes is a chance for

16:34

you to go back and correct your prompts. And we

16:37

can only do that if we have our prompts documented

16:40

in commands. That's 1 of the beautiful parts, being able

16:43

to systematize things so we have the opportunity to keep

16:46

improving

16:47

our commands. And also, it's obviously a waste of time

16:50

if we don't use commands. 1 minute to type a

16:52

prompt, that can be hours a month if we're typing

16:54

something hundreds of times. It's also inconsistent. We might sometimes

16:58

forget part of our prompt or what we need to

17:00

ask if we don't have it as a command. And

17:02

then also the knowledge is not shared. We can take

17:04

these commands and include them as a part of our

17:06

GitHub repositories or just send it as a zip file

17:08

to your coworkers or teammates. Like, whatever it is, we

17:10

can share these things so that our workflow is something

17:13

that other people can leverage immediately without us having to

17:16

explain things in a ton of detail or have some

17:18

kind of, like, 1 hour session where it's like, oh,

17:20

here's how I'm working with our coding assistant on our

17:23

code base right now. Right? If we can just share

17:25

the the commands. It is a beautiful thing. So there

17:28

you go. That is your overview of commands or reusable

17:31

prompts. And as we go into the next couple of

17:32

videos, I really want you to start to think to

17:34

yourself, what are the processes that I can automate and

17:37

turn into the commands? And there's probably going to be

17:41

an opportunity for almost everything that you're typing your coding

17:44

assistant right now. And so in the next video, I

17:47

wanna help you build your commands.

17:49

The primary mental model for how to structure things and

17:52

make it very easy for you to think about a

17:54

process

17:55

and then just go into the markdown document, use a

17:58

coding assistant as well to help you, but build out

18:00

the structure and start to create your own command library

18:03

for your system.