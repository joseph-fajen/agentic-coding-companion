---
course: Dynamous Agentic Coding
module: 4
lesson: "4.3"
title: "Universal Command Patterns"
type: lecture
status: raw
date_added: 2026-02-18
date_modified: 2026-02-18
tags:
  - dynamous
  - agentic-coding
  - module-4-commands
  - command-patterns
  - prime
  - plan
  - execute
  - commit
key_concepts: []
prerequisites: ["4.1", "4.2"]
related_lessons: ["4.4", "4.5"]
---


At this point, we have gone through the entire diagram

00:02

for module 4. Congratulations.

00:05

Now what I wanna do with you is get super

00:07

practical showing you the specific commands that I use in

00:11

all of my AI coding systems. We have the core

00:14

4. I'm gonna talk about how those work and how

00:17

they play really well together, and then I'll show you

00:19

an example of a different kind of workflow we can

00:21

build that I use quite a bit to help us

00:24

address issues and bugs in our code base. And so

00:27

we'll actually see this workflow in action. The core 4,

00:31

I'm not gonna cover in action right now because that's

00:34

what the next 3 modules are all about. And we

00:37

really get into a complete example of the PIV loop,

00:40

not just an overview. We're gonna be using these 4

00:43

core commands

00:44

as the foundation of our system throughout the entire implementation

00:48

we do in the next few modules. So I'll talk

00:49

about them at a high level, and then you're gonna

00:51

see these a ton throughout the rest of the course.

00:54

And then I'll give you a good demonstration here. And

00:56

all of these commands that you're looking at right here,

00:58

I have them in the folder for video. So you

01:00

can use these as a starting point to build the

01:03

commands for your own library, for your system. And these

01:08

commands for commit, execute planning, all of them, they are

01:11

optimized

01:12

for you to build on top of. So they're a

01:15

bit more of a general version of what I use

01:17

in my code bases, but still a fantastic

01:19

starting point for you to create your own commands. I

01:22

do want you to customize these to really make them

01:25

optimal for you, but it is a fantastic starting point.

01:28

And remember, we are following the input process output mental

01:32

model for all of these commands. I don't say it

01:35

explicitly or, like, comment that explicitly in these commands, but

01:38

it is always following this structure. And so our 4

01:41

commands that I wanna cover first here. We have 1

01:43

to understand the code base so our coding assistant can

01:47

prime itself.

01:48

We have 1 to plan what we want to build.

01:50

That's what gets into the structure planning.

01:52

We have 1 to implement the structure plan, then 1

01:55

to save our work.

01:57

And this is end to end, start to finish building

02:00

any new feature into our code base. So we can

02:02

apply a very similar flow for working with brand new

02:05

projects. We'll see exactly how that's a little bit different

02:07

in the next module, but this is always the foundation.

02:11

And so with that, let's start with our prime command

02:14

for our context loading. So priming is especially important when

02:18

working on existing code bases. That's generally where you'll use

02:21

it because when you start a new conversation with your

02:23

coding agent, it doesn't have any clue about what your

02:26

project is all about. And so you need to basically

02:28

catch it up to speed on your code before you

02:31

go into your next feature implementation.

02:33

Because it needs to know things like integration points, what

02:36

files do I need to edit to build in the

02:37

feature, what do I have to create versus what's already

02:39

there. That is what the priming command accomplishes for us.

02:42

And so I'm gonna show you all these commands at

02:45

a very high level right now just to cover the

02:46

principles of each 1, and then you'll really see them

02:49

in action and I'll cover it in a lot more

02:51

detail in the next 3 modules.

02:53

And so starting with Prime, open up the preview here.

02:56

The goal here is just to analyze the project structure

02:59

and read the core files. And so it'll list track

03:02

files with Git, analyze the directory structure, and you could

03:05

tweak this however you want. Reading the core files like

03:08

the read me, for example,

03:09

and then some of the key files we have in

03:12

our project. And so just think about, like, how would

03:13

you wanna tell a person how to catch themselves up

03:16

to speed on your project? And you just do the

03:17

same thing for priming.

03:19

And so global rules already cover

03:22

some of the priming. Right? Because you are speaking to

03:25

the architecture and tech stack of your code base there,

03:27

but priming is where you can get a lot more

03:29

specific and really dig into the code base. The kind

03:31

of thing that you don't want by default in the

03:33

global rules because you don't want to bloat it. And

03:34

so your global rules plus your priming is what you're

03:37

going to have for your coding assistant going into a

03:40

feature implementation.

03:41

And if you wanna get a little fancy here, I

03:43

love doing this. I like adding parameters

03:46

to my prime command. Like what to focus on, like

03:49

prime yourself on the front end because I'm going to

03:51

do a front end implementation.

03:53

Or you could say I want you to reference

03:55

this layer 1 planning on demand context. Like pull in

03:58

this guide because I'm about to add a tool to

04:02

my coding assistant. So I want a prime specifically for

04:05

adding tools to my agent.

04:07

And so you can do some pretty awesome things with

04:09

prime here. So this is a very generic implementation. You

04:12

can add in parameters. You can tweak how it analyzes

04:14

your code base. This This is 1 of the things

04:16

that you definitely want to customize.

04:18

And so with that, let's go on to the next

04:20

1 here, which is our planning command. So the planning

04:24

command replaces a lot of the manual prompting that we

04:26

did in module 2 because this is also where we

04:29

specify

04:30

the structure of our plan that we are then eventually

04:34

passing to the execute command. And so we're researching and

04:37

creating that detailed implementation plan based on the template, like

04:40

all of the sections that we want, like success criteria

04:43

and the task list and things like that. And the

04:45

interesting thing here is that the consumer of the plan

04:49

is another agent. And so remember, think from the agent's

04:52

perspective. When we will have the plan created here, we

04:55

want it to be created in a way that's optimized

04:57

for a coding assistant. We want it to be very

04:59

detailed, laying it on all the specifications for the feature

05:02

that we're building. So the priming command is a bit

05:04

different because the consumer is you, because it's your job

05:08

to verify that it actually has a good understanding of

05:11

the code base after you run Prime. But for the

05:14

planning, it is another agent. And so you're gonna be

05:17

using this command after you've primed and you've got all

05:20

your layer 1 context set up and everything. You're going

05:23

into your feature implementation. So we are using these commands

05:26

in order in our systems almost all of the time.

05:30

And I'm not gonna cover this in a lot of

05:32

detail right now because we will really get into this

05:35

actually in the very next module. But, yeah, we have

05:38

our research process.

05:39

And then after that, we're creating the plan document. And

05:42

then we outline the structure that we have here, like

05:45

our task list and what we wanna do for validation.

05:49

This is a more basic example of what I typically

05:51

use just to keep it short and concise, but that

05:53

is the general idea. Do some research, create the structured

05:56

plan.

05:57

And then after we have the plan, obviously, it's time

05:59

to go to execution.

06:01

And by the way, you do wanna be in the

06:03

middle of running these different commands. Right? Like, we don't

06:05

have an automated workflow at this point where we're going

06:08

straight from planning to execution.

06:11

We want to validate the plan and iterate on it,

06:13

then we are ready to go to execution. And so

06:16

the consumer of the execution command really is you because

06:19

it's your job to validate the code produced by your

06:22

coding assistant. So the

06:24

AI coding assistant has already done its validation as a

06:27

part of the structured plan. Now it's your job to

06:30

do the code review and manual tests just like we

06:32

covered in the PIV loop earlier. And so that's why

06:34

I'm saying you are the consumer as well as Git

06:36

because that'll get into the commit command in a second

06:39

here. So we run execute on our plan. It's going

06:42

to read that plan, and then this is really 1

06:44

of the more basic commands here because we're just telling

06:46

it how to read the plan and then how to

06:49

handle the task management.

06:51

And then just speaking to the validation fans, like, making

06:54

sure we run those in the plan, and then final

06:56

verification. Then we just, of course, have the output section

06:58

at the end describing to the coding assistant how to

07:02

specify what it did,

07:04

like, what files it changed specifically

07:07

when it executed the plan. So nice and simple overall.

07:10

And then once we have the code changes and we

07:13

have validated things and iterated as needed, that is when

07:16

it's time to commit things. And so we are using

07:19

Git. Like, Git is the sneaky little thing where it's

07:21

actually, like, super critical to everything we're doing in DynaMix

07:24

and the agent coding course. And so, obviously, every time

07:27

we have this save state, like, we're ready to create

07:30

a save state in our code, that's when we run

07:32

the commit command. And so the consumer is obviously get

07:35

our version control system, and then it's anyone that's gonna

07:38

be reviewing our changes, like ourself, another coding agent we

07:40

have in GitHub, like CodeRabbit, whatever that might be. Right?

07:43

Like, that's the consumer

07:44

of the final save state that we produce. So for

07:47

our commit command, we have our description,

07:49

we got the allowed tools I talked about earlier. Also,

07:51

there's argument hints, which I haven't mentioned before, but that's

07:54

just a way to when you're invoking the command in

07:57

the cloud code specifically,

07:59

it gives you a little bit of help of, like,

08:01

what are the arguments that we can specify for the

08:03

parameters. So that's just another little golden nugget. That won't

08:06

help with coding assistance outside of cloud code, which is

08:08

why I haven't focused on it, but this is something

08:10

that I use for a lot of my commands. But

08:12

anyway, for commit here, files that are specified, arguments. So

08:16

if we want to create a save state for specific

08:19

files only, we can call that out. Otherwise, if we

08:22

don't pass any arguments, then it's going to commit all

08:25

changes. So we can also be dynamic with the number

08:27

of parameters that we give to some of our commands.

08:30

So I'm just showing that in action here as well.

08:32

And then we're going to automatically inject some git context

08:36

because we have the exclamation marks here. So these are

08:39

run and injected automatically.

08:41

And then we are analyzing the changes. Let me go

08:43

into the better preview here. We're analyzing the changes, staging

08:46

the files, and then we are committing and then confirming

08:48

that our commit was successful. And then just outputting exactly

08:52

what we did with our commit, like details, like the

08:54

commit hash and other metadata, the message. So, yeah, very

08:57

descriptive. And then at that point, we can read that

09:00

and then know exactly what we have in our current

09:02

safe state and what the description the coding has just

09:05

then gave for the changes as well. And so this

09:07

is kind of the end of 1 iteration of the

09:09

PIV loop really. Right? Like, we did the priming then

09:11

planning, then we executed on the structure plan, iterate until

09:14

things were good, and now we have our save state.

09:16

And then boom, we can now move on to the

09:18

next PIV loop. And so real quick, 1 prerequisite for

09:21

this workflow is you do have to have the GitHub

09:24

CLI installed because that's how in the command line our

09:27

AI coding assistant is gonna be able to reach out

09:29

to GitHub and pull the issues that we have created

09:31

there. So I've got quick instructions to get that installed

09:34

and verify the installation

09:36

in the read me that we have for this video

09:38

and link to this folder in the description like I

09:41

have for all the videos here. And so once you

09:43

have it installed, you can do a g h issue

09:45

list in your repo. And so we're gonna be making

09:48

a little bit of a bug fix here in our

09:51

Obsidian AI agent repo that we worked in in module

09:53

2. So I'll just do a GitHub issue list,

09:56

and there we go. We have a single issue that

09:59

I created a minute ago for our recording.

10:02

And so this issue is the 1 that we're going

10:04

to address

10:05

with those commands that I've put in here. And so

10:08

I have all the core commands and our bug fix

10:11

workflow commands put into the dot cloud slash commands folder

10:14

for Obsidian AI agents. So I just copied them right

10:17

over from

10:18

the course repo that we're looking at earlier. And so

10:21

we're gonna start with RCA in a second, but first

10:24

I wanna show you the issue that I have. And

10:26

so I want something really, really basic because I want

10:29

to show the process versus, like, actually fixing something complex.

10:33

And so I took a look at the read me,

10:34

and I was like, oh, you know what? The quick

10:36

start here, like, how to install and run everything, like,

10:39

it actually makes sense for this to be way further

10:41

up in the read me. We don't really wanna care

10:44

about the core tools until we have the application up

10:46

and running. And so that is the super basic GitHub

10:49

issue I created here. I just said the quick start

10:52

and the read me should be closer to the top.

10:53

It doesn't make sense that the tool descriptions is above

10:56

it. Right? So super simple. You could imagine this would

10:58

be a much larger description of a problem, like some

11:01

bug in the code, but we can still run the

11:03

full workflow and see it in action on something super

11:05

basic like this. And so I'm going to open up

11:07

Claude. I'm gonna do it in dangerously skip permission or

11:11

YOLO mode just so that for the sake of brevity

11:13

here, it doesn't ask me for permission to do anything.

11:15

And then I'll do slash r c a. And then

11:18

because of our argument hint, it tells us that we

11:20

should specify the GitHub issue ID, which the ID is

11:24

just a 1. So slash r c a 1. Boom.

11:27

There we go. Our entire process. We have kicked off

11:31

by typing literally 6 characters

11:33

slash r c a space 1. There we go. So

11:36

it's gonna use the GitHub CLI to analyze the GitHub

11:39

issue. That's a part of what we specify in the

11:42

command. Like, we tell it to use the GitHub CLI.

11:45

So there we go. It reads the issue, and now

11:47

it's going to do a bunch of root cause analysis.

11:49

In this case, really just has to read the read

11:51

me, and then it'll spit out its recommendation here. So

11:54

I'll pause and come back once we have that. Alright.

11:56

Nice. Just a minute later, and we have our root

11:58

cause analysis complete.

12:00

And as a part of the process,

12:02

we tell it to write out to a document. So

12:04

now we have in this new docs folder, r c

12:06

a issue 1 dot m d. And so this is

12:09

a summary of the problem and then also

12:12

what it is recommending for the solution here. So might

12:16

be a bit longer than I need, but that's totally

12:18

okay. Here's our proposed fix. I guess it's not that

12:20

long overall,

12:21

because this is definitely a command that's meant more for

12:24

real complex issues. So, yeah, I'll go back into the

12:27

terminal here and it even says that the next step

12:29

is to run implement fix, which we could do this

12:32

in a brand new conversation because the RCA document, like,

12:36

this is literally all we need as context to now

12:39

implement the fix. It's very similar to what I showed

12:41

you module 2. Like, once we finish our structure planning,

12:44

we can clear the conversation

12:46

and run the execute command just to keep our context

12:48

window nice and concise. So I'll do slash implement fix,

12:52

and then again, we just need to specify the GitHub

12:55

issue ID. Because as a part of the command I'll

12:57

kick this off and show you here. As a part

13:00

of the implement fix command, it's telling us the RCA

13:03

document exists at docs slash RCA and then issue dash

13:07

and then the argument, which is the GitHub issue ID,

13:10

and that's gonna pull in the exact right file. So

13:12

this command does assume that we ran RCA first, but

13:15

that is the workflow that I have defined here. And

13:17

we could even chain these together if we want, which

13:21

in 2 videos from now, I'll show you an example

13:23

of chaining a workflow just to give you a bit

13:26

of a teaser for what comes next when we automate

13:28

things in the next release batch of the course. And

13:31

so, yeah, I'll go ahead and pause and come back

13:34

once it has implemented our fix. And boom. There we

13:37

go. We have now implemented a fix for our read

13:40

me. Be probably good after you run the implement fix

13:43

to validate the changes yourself. We're not gonna do that

13:45

since this is a quick demo. But, yeah, it's also

13:47

really cool that the output of the RCA command is

13:50

directly the input. Like, this document

13:52

is all the context for the implement fix. So it's

13:55

a good example of how you wanna think from the

13:58

agent's perspective. How should we formulate

14:00

this issue markdown document? Not for our readability. I mean,

14:05

this is very long. It's not for us as a

14:07

human. It's for the coding assistant once we go to

14:09

the next part of our workflow in our system. Very,

14:13

very cool. And so with this, I can now do

14:15

slash commit, and I'm not gonna specify any files here

14:18

like I could because I just wanted to commit everything

14:20

that it did. And so this is going to create

14:22

that save state, push things into git, and we'll have

14:25

our fix saved to the cloud. And there we go.

14:28

It got everything committed with a really nice commit message

14:31

for us. And now all I had to do was

14:34

run the git push commands. That's the 1 thing that

14:36

I don't specify in the workflow just to give us

14:38

room to validate things before we commit it to our

14:41

GitHub repository.

14:42

And a quick pro tip for you, if you want

14:44

to execute your own bash command while you're in the

14:47

cloud code session,

14:48

all you have to do is the exclamation mark just

14:51

like we want to execute commands directly when we load

14:54

our commands. And so I just did exclamation mark git

14:56

push. That's what I ran,

14:58

just here off camera so that everything is pushed to

15:01

our GitHub repository now, and our issue has now been

15:04

addressed. So that is the full workflow. So with that,

15:07

that is all the core commands that I wanted to

15:09

cover for you in this module. We saw the prime

15:11

plan execute

15:13

and commit. And then the 1 that we just saw

15:15

in action was the root cause analysis, then implement fix,

15:18

then commit. And you could also do a prime before

15:21

the RCA as well. I wanted to make sure I

15:22

document that, but I took that out for the sake

15:25

of speed. And then also just to show you that,

15:27

like, these processes that we have defined or, like, our

15:30

original intended purpose for a command in a system is

15:33

not rigid. It can be very flexible. You can pick

15:35

and choose the commands we wanna use for what we're

15:37

currently doing, and that's part of the beauty of making

15:40

these so modular. And so I just did RCA employment

15:43

fix and commit. I didn't even include this, though maybe

15:46

it would be nice to do that as well. And

15:48

so the next thing that I have for you is

15:50

the exercise for this module. And there are 2 parts

15:54

to this exercise. 1, I want you to create your

15:56

own command so you can start to practice building up

16:00

your own systems. And then the second thing, since a

16:03

structure plan is such an important part of the PIV

16:06

loop, the second part of the exercise is for you

16:08

to define your own structure, like your planning template that

16:12

you'll include in your planning command. So really excited for

16:16

that. It's gonna be very hands on for you, taking

16:18

in all the ideas that we've covered so far in

16:21

this module. And there'll also be a bonus video after

16:24

on chaining commands together. So I'll see you in the

16:27

next video for the exercise.