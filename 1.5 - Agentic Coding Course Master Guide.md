---
course: Dynamous Agentic Coding
module: 1
lesson: "1.5"
title: "Agentic Coding Course Master Guide"
type: overview
status: raw
date_added: 2026-02-18
date_modified: 2026-02-18
tags:
  - dynamous
  - agentic-coding
  - module-1-introduction
  - master-guide
key_concepts: []
prerequisites: ["1.1", "1.2", "1.3"]
related_lessons: ["2.1"]
---


So I'm adding this video into module 1 after I've

00:03

already completed the entire agentic coding course because I wanna

00:07

cover the course progression

00:09

and the entire AI coding workflow that we go over

00:11

in this course with you.

00:13

Some of the first people to go through the agenda

00:15

coding course, they gave me some feedback that the content

00:18

is awesome, but what was really missing is a single

00:21

diagram

00:22

to see at a bird's eye view the entire system

00:26

for AI coding that we go through going all the

00:28

way through module 7 of the course. And so that's

00:31

what I have for you right here and what I

00:33

wanna cover very briefly in this video. And please use

00:37

this diagram as a reference so you always know where

00:40

you're at in the modules and you have that high

00:42

level view of your entire system for AI coding. And,

00:46

of course, I obviously have this in the agentic coding

00:48

course repository as well. So I'll link to that in

00:51

the description too. So what I wanna go over with

00:54

you briefly right now is our course progression, and then

00:58

how that maps to the entire

01:00

AI coding workflow that we cover in modules 2 through

01:03

7. So zooming in here, I wanna start with the

01:06

course progression because it's really important to understand 3 things.

01:10

What each module is about,

01:12

how they play into each other, and when it comes

01:14

time for you to actually apply things to your own

01:17

projects. And so starting with the fundamentals here, module 1

01:21

and 2. So module 1 is all about feeling the

01:24

pain of not having your own

01:26

system. And then in module 2, I will start to

01:29

introduce you to the PIV loop. That is the core

01:32

mental model that will guide all of our feature development

01:34

in our system for agentic coding.

01:37

And so at this point, we are not building our

01:40

system yet. We're just covering the principles

01:42

that are going to lay the foundation for us with

01:45

everything we have in the modules 3 and beyond. And

01:49

so speaking of that, when we get to modules 3

01:51

and 4, this is where we start to create our

01:54

system components.

01:55

We have our global rules and on demand context to

01:58

steer our coding agents.

02:00

We have our commands. These are our reusable prompts that

02:03

really start to define our workflow.

02:05

Very, very powerful stuff. At this point, we are building

02:08

the pieces, but we're not assembling anything yet into our

02:11

complete system.

02:12

That is what we start to do in modules 5

02:15

through 7. So this is the big inflection point where

02:18

everything starts to come together, and this is where I

02:20

really encourage you to start to take what you're learning

02:23

here and apply it to your own projects.

02:25

Because we cover the PIV loop in module 2, we

02:28

have the components for our systems in module 3 and

02:30

4, and now everything comes together where we're going to

02:33

build a project completely from scratch. And we'll apply our

02:37

rules and commands and things like that to each stage

02:40

of the PIV loop. And so this is where we

02:43

really build with our system. And modules 5 through 7

02:47

really are the meatiest part of the course. Honestly, the

02:49

most important for at least the core system that we

02:52

cover in the agentic coding course. Because modules 8 through

02:56

12, they're still very important, but this is where we

02:59

just get into some of the more advanced concepts for

03:02

automation and scale. So more tools that we can build

03:05

into our system with MCP servers and skills,

03:08

remote agentic coding, which we cover in modules 8 and

03:11

9, so we can use our agents wherever we want.

03:14

And then we get into more advanced concepts like sub

03:16

agents and parallel agentic coding. So this is all about

03:19

taking our systems beyond the terminal and leveling them up

03:22

with more tools.

03:24

So that is the course progression at a high level.

03:26

Remember, go through modules 1 through 4 by just absorbing

03:30

the ideas and going through the exercises, and then start

03:32

applying things right here. So the next thing that I

03:35

wanna cover is a bird's eye view for the entire

03:38

system that we cover in the course because I want

03:40

you to be able to reference back to this whenever

03:42

you want, working on your own projects or just trying

03:45

to see where the current module fits into the entire

03:48

process. And really for our system, there are 3 primary

03:51

components. First, we have our AI layer. This is defining

03:55

all of the context that we give to our AI

03:57

coding assistant

03:58

throughout the process.

03:59

And then the biggest box here is our PIV loop

04:03

because this really is the primary mental model that guides

04:06

all of our agentic engineering. We plan, then we implement,

04:09

and then we validate. We're gonna see this theme and

04:12

this process in pretty much every single module in the

04:15

course. And then last but not least, we have everything

04:18

related to system evolution.

04:20

Because remember, when we encounter a bug in our code,

04:24

don't just fix the bug. We want to fix the

04:26

system that allowed the bug. And so we reflect back

04:30

on our AI layer, and we can use AI coding

04:33

assistance to help with this as well, to think to

04:36

ourselves. Like, should we update something in our rules? Is

04:39

there a command that we should change or add? What

04:42

can we improve in our system, in our AI layer,

04:45

to avoid that problem that maybe we're seeing come up

04:48

time and time again as we're executing PIV loops to

04:51

build out our code base? Okay. So with that, I

04:53

wanna dive into this process a little bit deeper right

04:56

now, and then also call out specifically which modules I

05:00

focus on each thing. Now, of course, your process is

05:03

going to differ depending on if you're working on a

05:06

project from scratch, I e greenfield development,

05:09

or if it is brownfield, applying an AI coding assistant

05:13

to an existing code base for the first time. So

05:16

I do want to dive in and cover both briefly

05:19

with you right now. So when you're starting your code

05:21

base completely from scratch, you have the unique opportunity

05:25

to build an AI optimized template. So you're creating the

05:28

foundation of your project that is optimized for coding assistance

05:32

to understand things and build on top of it. Now

05:35

this is a more advanced concept that requires you to

05:38

understand code more, so that is why I put it

05:40

as optional, and I have this at the end of

05:43

modules 2 through 7.

05:45

But if you are an engineer, you understand coding assistance

05:49

already, or if you really just wanna optimize things from

05:51

the get go, I would actually encourage you to go

05:54

through this workshop right after this video. So I will

05:58

link to this in the description. It is a great

06:00

resource to get you on the ground running, going through

06:04

everything else going forward.

06:06

Next up, we have creating our PRD.

06:08

This is the high level scope of work that we

06:10

want to give to our coding assistant so it knows

06:12

what we should be building out through many different PIV

06:15

loops. And I cover that at the start of module

06:18

5. Now the reason why it's at the very beginning,

06:21

but I cover it later in the course, is because

06:23

again, modules 1 through 4, all about building the pieces

06:27

for our system. But we only start to truly assemble

06:31

the system for our inflection point in modules 5 through

06:34

7. So the PRD comes first, but I want to

06:37

build that when we create our code base from scratch

06:40

after we have defined our core components.

06:43

And so that is why it is at the beginning

06:45

of module 5. And then after creating the PRD, that

06:48

is when we get into everything we cover in modules

06:50

3 and 4. We have our global rules and on

06:53

demand context to guide our coding assistant and give it

06:56

patterns for development. And then we have all of our

06:58

reusable prompts. I have the core 4 here for priming,

07:02

planning, executing, and committing. These play very well into the

07:05

PIV loop. I'll talk about that in a little bit

07:07

as well. Next up, we create our PRD. This is

07:11

the high level scope of work for our entire project.

07:14

So we're gonna knock this out through many different PIV

07:17

loops, and I cover this at the start of module

07:19

5.

07:20

Now here's the thing. We have some things that come

07:23

after

07:24

that I actually cover in earlier modules.

07:27

Why is that? Well, the reason is the PRD is

07:30

specific to greenfield development. In brownfield, we do something a

07:34

little bit different that I'll talk about in a second.

07:36

And so the building blocks of our system, our rules,

07:40

on demand context, and commands,

07:42

these are universal to any time we're working on a

07:45

code base, greenfield or brownfield.

07:47

So I wanna cover them first because remember, modules 1

07:50

through 4 is all about building the components and understanding

07:54

the core mental models of our system. And then modules

07:58

5 through 7, that's the inflection point. We're really starting

08:01

to bring things together.

08:02

Starting with creating our PRD,

08:05

because at the beginning of module 5, that's when I

08:07

show you building a project completely from scratch. So I

08:11

hope that makes sense. It also is more of like

08:13

a progression

08:14

of complexity versus the natural order because I wanna cover

08:17

the core things first, like the PIV loop, our rules,

08:20

and our commands.

08:22

And then for Brownfield,

08:23

things are very similar to Greenfield. So we understand the

08:27

code. So instead of creating a template from scratch, we

08:30

are now going to understand what we already have, and

08:32

then we're going to extract our global rules from that.

08:35

So we can continue to follow the patterns that have

08:38

already been established in the code base. We will then

08:40

also build up our commands, which again, I cover that

08:43

in module 4. And then instead of creating our PRD,

08:46

we're more going to document what we already have in

08:48

the code base, What has already been built and then

08:51

what we want to create next. So it's similar to

08:54

a PRD,

08:55

but it does have to be fundamentally different because we're

08:58

building an AI layer on top of something that has

09:01

already been created without AI coding assistance.

09:04

But in the end, both workflows converge into the same

09:08

PIV loop process.

09:09

So once we create our initial AI layer, now all

09:13

we're gonna be doing is just running PIV loops per

09:15

feature. And that's why it's called a loop because we're

09:18

gonna go through this process of planning,

09:21

implementing,

09:21

and validating until we have everything built out in our

09:25

PRD

09:26

or wherever we're documenting what we wanna create next in

09:28

our code base. And right away in module 2, I'm

09:31

gonna introduce you to the entire PIV loop. So we

09:34

do an overview of each component in module 2, and

09:37

then I dive a lot deeper into each of the

09:40

components in a dedicated module. So for example, module 5,

09:45

we're going to start a project from scratch, go through

09:47

the PRD and everything like I said earlier, and it's

09:50

really just like all of the commands and rules and

09:53

mental models around planning, the first part of any PIV

09:57

loop. And so these are the core commands that I

10:00

cover in module 4 that I apply in module 5,

10:02

and it's the same for the rest of the parts

10:05

of the PIV loop. Like, we do a deep dive

10:07

in module 6 in implementing.

10:09

We have the execute command for that, and then module

10:12

7 is all about the validation. So the end of

10:15

each PIV loop, doing a code review, even thinking about

10:18

how we can evolve our system. I cover that in

10:21

the module 7 as well. And so at the end

10:23

of each PIV loop, there is a big decision that

10:26

we have to make, and this is also what I

10:27

cover at the end of module 7. Because if there

10:30

are no major issues that come up after our PIV

10:33

loop, we can very simply just move on to the

10:36

next 1. So we do our VIE planning, we create

10:38

our structured plan, feed that into the coding assistant

10:41

for the coding, and then validate at the end. Like,

10:43

we can just go through that process

10:45

over and over and over again as long as things

10:48

are going pretty smoothly.

10:50

However, we have the other route to take here. Because

10:53

if we encounter any major issues with the PIV loop,

10:56

like there are bugs that we see come up time

10:58

and time again,

10:59

this is now our opportunity to evolve the system. Remember,

11:03

this is really worth repeating. Don't just fix the bug

11:06

when you see a pattern emerge. You want to fix

11:09

the system

11:10

that allowed that bug to happen repeatedly. It's not like

11:13

you're going to go through this system evolution process for

11:16

every little bug that comes up, but when you see

11:18

something that is starting to really plague you and happen

11:21

time and time again, that's when you wanna go through

11:24

this process. So when we encounter any kind of big

11:27

issue, like we deviate a lot from our plan during

11:29

implementation

11:30

or we encounter some kind of pattern of a bug

11:32

coming up over and over again, that is our opportunity

11:36

to look back on our AI layer and see what

11:39

we could fix so that this doesn't happen again. Maybe

11:42

you're gonna make an improvement to your commands,

11:44

add in some on demand context, change your global rules,

11:47

or adjust your plan template. It's generally gonna be 1

11:50

of these 4 things that you can improve, so so

11:52

that the next time you go into a PIV loop,

11:54

that issue doesn't happen again.

11:57

And so you can see how this is kind of

11:59

a meta loop that we have over the PIV loop.

12:02

When things are going well, we stay within this loop

12:05

right here. But when there is a problem that we

12:07

need to address,

12:09

we take a step back and we loop by going

12:11

back to our AI layer and seeing if there's something

12:14

that we created initially that we can evolve. And then

12:17

we can go back into the next PIV loop to

12:19

see if that issue doesn't happen anymore

12:22

now that we have evolved our system. And so going

12:24

into the next pivot loop can either be going into

12:26

the next feature or maybe you revert the current implementation

12:30

and you retry the exact same pivot loop to make

12:33

sure that the exact same feature implementation

12:36

does not have that same problem that leads you to

12:39

where you are right here. And that is a very

12:42

high leverage skill. This decision point is so important because

12:46

when you first create your AI layer, it's never going

12:49

to be perfect. But if you take every mistake here

12:53

as an opportunity to go through this process,

12:56

your AI coding system is just going to get more

12:59

and more bulletproof over time. So I hope that this

13:02

diagram can be a very useful resource for you as

13:05

you go through the course and apply everything you learn

13:08

to your own projects.

13:09

And if anything doesn't make sense here, especially after you

13:12

go through the modules for each component,

13:15

please let me know in the community. It is my

13:17

job to make sure that everything here is crystal clear

13:20

for you.