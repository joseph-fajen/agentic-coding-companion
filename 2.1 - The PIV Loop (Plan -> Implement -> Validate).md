---
course: Dynamous Agentic Coding
module: 2
lesson: "2.1"
title: "The PIV Loop (Plan -> Implement -> Validate)"
type: lecture
status: raw
date_added: 2026-02-18
date_modified: 2026-02-18
tags:
  - dynamous
  - agentic-coding
  - module-2-piv-loop
  - piv-loop
  - core-concept
key_concepts: []
prerequisites: ["1.5"]
related_lessons: ["2.2", "2.3", "2.4"]
---


Welcome to module 2 of the DynaMed agentic coding course.

00:04

This is where I introduce you to the most important

00:07

mental model that's gonna be driving everything we build together,

00:10

all of the workflows

00:12

and all of the systems.

00:14

If you've been following along, you just completed exercise number

00:17

1, a fairly simple task, but using your own tools

00:20

and your own process.

00:21

I hope that went well for you, but with that

00:23

as your baseline, now we can get into the PIV

00:26

loop. And so the way this module is gonna work

00:29

is we'll start by an introduction to the PIV loop.

00:31

I'll cover it in some more detail here. That's what

00:34

this video is right now. Then the 3 videos after

00:37

that, I'll be getting into planning, implementing, and validating. We'll

00:41

see it in action

00:43

actually covering the main build for this course. That's the

00:47

Obsidian second brain AI agent that I talked about in

00:50

the last module.

00:52

Then we'll get into exercise number 2, and your task

00:55

for this exercise is the same implementation,

00:58

but adjusting your approach to incorporate what we talk about

01:01

with the PIV loop, applying those ideas yourself. So I

01:05

hope that sounds good to you. With that, let's now

01:07

dive into the PIV loop. Now I know that I

01:10

already covered this to an extent in the introduction. And

01:13

I did that very purposefully because this is such an

01:16

important mental model that I wanted to expose it to

01:19

you right away.

01:20

But now we're gonna get into things in a lot

01:22

more detail and covering this as the cornerstone

01:25

for all of the workflows and systems that we build

01:28

in the rest of the course. And at the end

01:29

of this video, I'll even give you a teaser here

01:33

for how the PIV loop applies

01:35

to everything that we're gonna be building going forward together.

01:38

And pay attention to this. If you're brand new to

01:41

AI coding,

01:42

this is how I teach you how to think about

01:45

working with AI coding assistance and a lot of the

01:48

what and the why, the principles behind it. And if

01:51

you're already pretty adept at using AI coding assistance, I

01:54

still wanna get on the same page with you here

01:57

because this is a mental model as much as it

02:00

is a process. We're gonna be referencing back to this

02:03

time and time again, and so this really is the

02:06

cornerstone.

02:08

And so the primary mental model, we go from planning

02:11

to implementing

02:12

to validating and then iterating. This really is a loop.

02:16

And so we start, of course, with our planning.

02:19

And when you start with planning, I'm assuming that you're

02:23

opening up your AI coding assistant and you've got a

02:25

brand new conversation, blank slate, or starting from scratch. And

02:29

I'm gonna be speaking to how starting from scratch, we

02:33

can build a brand new project or build a new

02:36

feature in an existing code base. So I'm gonna be

02:38

talking about both. When I say from scratch, I'm just

02:41

talking about a new conversation with the coding assistant.

02:44

And so the very first thing I do either way

02:47

is I start with what I like to call a

02:49

vibe planning.

02:51

Now I am not a fan of vibe coding.

02:54

I really do think that you should understand everything that's

02:58

happening in your implementation

03:00

and be on the same page with the AI coding

03:02

assistant. But Vibe planning, I think is okay.

03:05

We don't have to have a lot of structure upfront.

03:08

When we are first beginning a new implementation,

03:11

all we want to do very casually is to explore

03:14

ideas with the AI coding assistant

03:17

to figure out our architecture,

03:19

understand concepts we're building, especially if you're newer to coding,

03:23

get a sense of what our tech stack should be

03:25

existing or new. We're just getting on the same page

03:28

with the AI coding assistant for what we want to

03:31

build. That is your number 1 goal at this point.

03:34

No structure,

03:35

just exploring.

03:36

And so for a new project,

03:38

this can look like quite a few different things, but

03:40

you're especially gonna be researching online resources

03:43

and potentially previous projects you've worked on that are similar.

03:46

This is gonna be a lot of your context that

03:48

you are exploring.

03:49

And then for an existing code base, it's going to

03:52

be researching

03:54

and analyzing that code base to figure out quite a

03:57

few different things. Where do we have to edit things

03:59

in our code base? What does our existing architecture look

04:02

like? So it's different things that you're interested in depending,

04:05

but it's the same idea overall.

04:08

And planning really has 2 phases to it, and we're

04:11

really gonna get into this in the next couple of

04:13

modules in the course. So don't worry if this isn't

04:16

super concrete right now. We're really gonna dive into this.

04:20

And so layer 1 is your project planning. This is

04:22

what you do once and you update rarely. So it's

04:26

gonna be 1 of 2 things. Either a brand new

04:29

project that you're working on with AI or it's an

04:31

existing code base that you're bringing AI coding assistance into

04:35

for the very first time. Because anytime you're working on

04:39

code with AI, you establish a sort of AI layer

04:42

where you have your commands and your rules, the constraints

04:46

that you have. And so this is your layer

04:49

to figure out all of that. And so you figure

04:51

out the tech stack with the coding assistant, the architecture,

04:55

the constraints that you have for it, your coding conventions,

04:58

and then you create your stable resources. These are things

05:01

like your global rules which we're gonna cover in the

05:04

very next module. And so you do this 1 time.

05:08

And then what I'm gonna be focusing on especially in

05:11

this module of the course is layer 2 planning. This

05:14

is your task planning that you're doing for every single

05:17

feature. So this is happening

05:18

quite frequently.

05:20

In fact, for every iteration of the PIV loop, you

05:23

are doing a task planning. This layer only happens 1

05:26

time. And so for every feature, you're going to analyze

05:29

the code base and documentation.

05:31

You're gonna figure out integration points. Basically, like what files

05:35

do I have to edit in my code base? What

05:36

do I have to create? And then also defining task

05:40

specific rules for your AI coding assistant.

05:43

And again, no structure at this point. You're figuring out

05:46

these things just with a simple conversation with the AI

05:50

coding assistant.

05:51

Now this might take 10 minutes. It might take a

05:54

half hour. Whatever it takes for you and and if

05:57

you're newer to AI coding or just coding in general,

05:59

this is also your place to ask a lot of

06:01

questions to the AI coding assistant to make sure not

06:04

only it understands what to build, but that you do

06:07

as well. Yeah. However long it takes you. Once you

06:10

get to the point where you feel like you've established

06:12

a good conversation with the coding assistant, then you can

06:15

move on to the second phase of planning. It really

06:18

is just 2 phases. I don't wanna over complicate it

06:21

here.

06:22

Phase number 2 is creating a structured plan with the

06:26

components of context engineering. And so this is where we

06:29

go from unstructured. We know what we're gonna build now.

06:32

Now we're gonna create a very structured plan so that

06:35

we can knock it out with the AI coding assistant.

06:38

The goal at this point is to produce a detailed

06:42

plan of attack for

06:44

your AI coder based on your conversation. So we're actually

06:48

using

06:49

this entire conversation

06:51

as context to create the structure plan, and that is

06:54

the very first pillar of context engineering. So I've covered

06:57

context engineering quite a bit on my YouTube channel and

07:00

in DynaMask.

07:01

This is sort of like a submental

07:03

model of the PIV loop for how we can think

07:06

about providing all of the context

07:09

necessary for the AI coding assistant to get the job

07:12

done, and there's 4 main components to that. So first

07:15

of all, we have memory. That's the generally the short

07:18

term memory of the coding assistant. In this case, we're

07:21

leveraging our vibe planning

07:23

to help it create our plan. And then we also

07:25

have a reg. That's providing any external documentation

07:29

or knowledge

07:30

to our coding assistant. That can be past projects, it

07:34

can be specific

07:35

websites we wanted to reference, like maybe documentation for libraries

07:38

that we're using. We're bringing that all in as a

07:41

part of the plan that is RAG. And then we

07:43

also have prompt engineering.

07:45

Specifically,

07:46

how we create our plan, the different sections that we

07:49

decide to have, I'll talk about that in a second.

07:52

That goes all into prompt engineering. Thinking about all of

07:55

the different pieces of information

07:57

that the AI coding assistant needs. And I talked about

08:00

this a little bit in the last module,

08:02

but 1 of the most important things, this is a

08:05

golden rule for working with AI coding assistants, you want

08:07

to limit the number of assumptions the AI coding assistant

08:12

makes and prompt engineering

08:13

is very big for that. We wanna be explicit in

08:16

everything as much as we possibly can be.

08:20

And then the last component of context engineering is task

08:23

management.

08:23

We always wanna have a task list that clearly lays

08:26

out how the AI coding assistant can split up the

08:29

implementation

08:30

piece by piece and knock it out 1 at a

08:32

time. So considering all of these different things,

08:36

this is the general list that I like to have

08:39

in my structured plan. And so when I say structured,

08:42

I really mean that we have different sections outlining things

08:45

like our goals, the success criteria,

08:48

the documentation that we wanted to reference during implementation,

08:52

our task list, the validation strategy, the desired code based

08:56

structure, and you can change this list to whatever you

08:59

want. Again, part of this course is helping you define

09:02

your own workflows, your own structure plans. This is just

09:05

generally what I recommend, and so you can use this

09:08

as a starting point and tweak it to however you

09:11

need. And in the next couple of videos here, I'll

09:13

show you exactly what this looks like. Actually, after the

09:17

very next video, we will have a full structured plan.

09:20

So I'll show you Vibe Planning,

09:22

going into structure planning in action. By the end of

09:25

next video, we'll have a markdown document that outlines all

09:28

of these goals for a specific feature implementation.

09:31

Alright. So I know I spent a lot of time

09:33

on the planning phase here, but that was very intentional.

09:37

I know it was almost 10 minutes,

09:38

but context is everything. Like I said, we want our

09:42

AI coding assistant to make the least amount of assumptions

09:45

possible, and that is all down to our planning.

09:49

And so if you really do have

09:51

a structured plan of attack for your future implementation with

09:55

sections that look something like this,

09:58

then once you get to the implementation,

10:00

things are actually pretty easy. Like, it's gonna take a

10:03

third of the time for me to cover both implementing

10:06

and validating

10:07

Because your plan of attack is all of the context

10:10

your coding assistant needs. And I'll show you this in

10:14

a couple of videos here, but when I go into

10:16

implementation,

10:17

I completely wipe my conversation history. I get a brand

10:20

new session with AI coding assistant,

10:22

and all I do is have it reference the plan

10:25

of attack and then go to town. That is it.

10:28

We are implementing

10:29

our plan task by task, and most of the structure

10:33

has already been set up. There might be a couple

10:35

of things that needs to research if we have some

10:37

rag items in the plan. But besides that, it's mostly

10:40

just gonna be writing the code and then validating which

10:42

we'll get into in a little bit.

10:44

And my mantra here during implementation

10:47

is to trust but verify.

10:50

As you create your structure plan, you should be a

10:52

part of that process and doing a lot of the

10:54

validating yourself. So once you get to the stage, you

10:56

should be pretty confident in what it's going to do,

10:59

but I still do generally verify a couple of things.

11:02

I'll watch my coding assistant loosely to make sure it

11:05

seems he's making the right tool calls, like, you know,

11:07

looking at the right files and understanding my documentation.

11:11

I'll make sure it's managing its tasks properly so it

11:14

understands the tasks it needs to pick out from the

11:16

plan.

11:17

And then making sure it produces thinking tokens

11:20

that show it understands the plan of attack. So for

11:23

a lot of AI coding assistants, they have slightly grayed

11:25

out text that will show up in the chat that'll

11:27

show kind of its reasoning tokens or what it's thinking

11:30

to itself. And that's a good way for you to

11:32

appear inside the mind of your coding assistant a little

11:35

bit to make sure that it's understanding your plan correctly.

11:38

You wanna make sure that disastrous things don't happen. Like

11:41

sometimes it'll only read part of your plan, for example.

11:44

It's been a really long time since I've had that

11:47

happen, but just saying like those

11:49

really, really crazy things you just wanna do a quick

11:51

sanity check and make sure it's not doing that. That's

11:54

what I typically like to validate. And then generally a

11:56

part of your plan is also the validation strategy. So

12:00

these 2 things actually mesh together quite well because the

12:03

AI coding assistant

12:05

is going to run things like unit tests and integration

12:09

tests and linting

12:10

right after the implementation

12:12

probably without you having to prompt it again

12:15

because it is a part of your plan.

12:18

And so the validation,

12:19

these 2, I'm going to cover in separate videos, but

12:23

it's really gonna be like, I'm gonna stop 1 video

12:26

in the middle of the AI coding assistant executing my

12:29

plan and then pick it up for the validation video

12:31

in the middle because it's going to knock all these

12:34

things out together and then it's up to us to

12:36

do some validation afterwards. And so typically after the AI

12:39

coding assistant is done with a feature implementation,

12:42

I e it's gone through my entire plan, I'm going

12:45

to perform a manual code review.

12:47

And it is okay if you don't know how to

12:50

code

12:51

extremely well. You can always have the AI coding assistant

12:55

help you with the code review

12:57

by asking it some questions about things that you don't

12:59

understand. Like maybe it decides to change something in a

13:02

database table or it tweaks your authentication provider. Well, you

13:05

can just ask it like, why did you do that?

13:07

Explain this code to me. The goal overall is just

13:10

to make sure that you understand why things were changed

13:12

the way that they were, even if it is just

13:14

at a high level. And then, of course, along with

13:16

the code review, I always run manual tests. Like, no

13:19

matter what the application is, if it's an AI agent

13:21

or a website or whatever, I'm going to run it

13:24

and play around with it as a user would normally

13:26

interact with it and just make sure that things look

13:28

good. And that is validation. So it's both our responsibility

13:32

and the AI coding assistant to validate things. For the

13:35

coding,

13:36

this should just be the AI coding assistant's responsibility. Right?

13:40

That goes with what I was saying in the last

13:42

module where when the code doesn't work, instead of doing

13:44

a 1 off fix or fixing anything yourself, you should

13:47

improve the system and then retry. It's very high leverage.

13:51

So

13:51

this is for AI. This is for you and AI

13:55

because we always want to be the validator. We wanna

13:58

be upfront planning and we wanna be at the end

14:01

validating and then delegating everything else to the large language

14:05

model. So I hope that makes sense. And then in

14:08

the next couple of videos here, we'll see this all

14:10

in action. So everything that I cover here, I'll be

14:13

referencing back briefly again and making everything very concrete for

14:17

you. Alright. And the last thing that I wanna cover

14:19

with you before we get into applying everything in the

14:22

next videos

14:23

is how the PIV loop plays into building systems and

14:27

workflows.

14:27

Because I'm sure you're asking yourself at this point, Cole,

14:30

where are the systems and workflows? I mean, with the

14:33

PIV loop here, we're still manually prompting everything for the

14:36

AI coding assistant and you're covering nothing with commands and

14:39

global rules and all of that yet. How does this

14:42

all evolve?

14:43

And trust me, this will evolve and it'll evolve quite

14:46

quickly. So I wanna cover this quickly with you to

14:49

give you a quick road map of how this all

14:51

works and to assure you that we're covering the foundations

14:54

for a reason here. And we're quickly gonna get into

14:56

the very exciting and even more advanced stuff that we're

14:59

gonna step into quite easily because we're laying down the

15:03

cornerstone together. So right away in the next 2 modules,

15:06

I'm gonna dive really deep into global rules and slash

15:09

commands with you. Sub agents will cover more later, but

15:13

these are the 3

15:14

core components of AI coding assistance, and they apply

15:18

to all 3 of our stages with the PIV loop.

15:21

And global rules and slash commands in particular are crucial

15:25

for the first version of our AI layer, as I

15:28

called it earlier.

15:29

The AI layer is the context that we inject directly

15:32

in our code base that our AI coding assistant leverages,

15:35

especially

15:36

as we start to get into building systems. So global

15:39

rules and slash commands are critical

15:42

for building reliable

15:43

and reusable workflows

15:45

for our PIV loop. And that's why the PIV loop

15:48

is so important. Even as we start to automate things

15:51

and build systems with slash commands and global rules, we

15:55

are still always going to be building around the principles

15:58

of the PIV loop. So right now as I introduce

16:01

you to these ideas and mental models, we're doing things

16:05

more manually, prompting our AI coding assistant. You'll be doing

16:08

that even in the second exercise here.

16:11

Now on the other end of the spectrum, we have

16:13

things very automated. We have these different commands that we

16:16

chain together. That's really how we build these systems. And

16:19

so we're only really in the loop as much as

16:22

we want to inject ourself for validation. Right? So it's

16:25

kind of the spectrum of how involved we are, like

16:28

being super, super involved versus letting the AI coding assistant

16:31

really run wild with these workflows that we create. But

16:34

here's the thing, no matter where you are in this

16:38

spectrum, we are still applying all

16:40

of the principles we have in the PIV loop. Like

16:43

if we're building a workflow around planning, well, we're gonna

16:46

be building it around the 4 pillars of context engineering,

16:49

and we're gonna have this structure. And then when we

16:52

create workflows around validating, for example, we'll still build in

16:56

those places that we want to be in the loop.

16:58

We'll still think about the tools and MCP servers that

17:02

we build in for unit testing and integration testing. Like

17:05

no matter how advanced we get, it still comes back

17:07

to the core principles here. And so mastering this is

17:10

what allows us to move very quickly through building powerful

17:13

systems and workflows and even getting to the point where

17:16

we can get to fully remote

17:18

AI coding workflows. Towards the end of the course, I'm

17:20

super excited for this. Already prepping a lot to share

17:23

with you in templates and resources, but being able to

17:25

build these workflows that we can interact with from our

17:28

phone or create a task in something like Asana or

17:31

Notion. And then a coding assistant is kicked off to

17:33

go through the full PIV loop, and we can have

17:35

ourselves in the loop wherever we want. That's up to

17:37

you to define. I'll show you how to build these

17:39

things. I'll even have some kind of out of the

17:41

box solutions you can use as well. So we can

17:44

go very, very far assuming

17:46

we have the PIV loop mastered. And so no matter

17:49

where you're at in your journey with coding or using

17:51

AI coding assistance,

17:52

go through this process with me. Really go through the

17:55

exercises

17:56

and get to that point where we have the PIV

17:58

loop mastered,

17:59

then we get into global rules and slash commands. We

18:02

use that to build our systems, then get more and

18:04

more advanced. It's a very exciting journey that we have

18:07

together here. So that's everything that I got for an

18:10

introduction to the PIV loop. I hope this all makes

18:12

sense to you and of course always let me know

18:14

in the community if you have any questions on any

18:16

of this.

18:18

And in the next few videos, we'll really get practical

18:20

here. So I think that'll help you as well. So

18:22

with that, on to the next video where we will

18:25

see the entire planning process in action on the main

18:28

build for our course.