---
course: Dynamous Agentic Coding
module: 4
lesson: "4.4"
title: "Exercise - Build Your Own Commands"
type: exercise
status: raw
date_added: 2026-02-18
date_modified: 2026-02-18
tags:
  - dynamous
  - agentic-coding
  - module-4-commands
  - exercise
key_concepts: []
prerequisites: ["4.1", "4.2", "4.3"]
related_lessons: ["4.5", "5.1"]
---


Now it is time for your module 4 exercises. There's

00:03

2 things that I want you to build here. And

00:05

so I'll go through exercise number 1 with you, and

00:08

then I'll give you the solution, and then I'll do

00:10

the same thing for exercise number 2. So exercise number

00:13

1 is all about building your own command following everything

00:16

that we've covered in the last few videos. And then

00:19

exercise number 2 is all about creating your own structure

00:24

for your plans. And so it's creating that template that

00:27

you're going to inject into your planning command or reusable

00:31

prompt. And so in this folder that I'll link to

00:33

in the description for this video, I've got a subfolder

00:36

for each of the exercises and then a primary markdown

00:39

document which is kind of the read me for each

00:41

exercise

00:42

as well as the solution. So don't peek at the

00:44

solution yet. I really want you to go through this

00:46

as an exercise to start to build up your system,

00:49

build up your workflow library. And so for exercise number

00:53

1, let's go ahead and dive into this. And so

00:56

it's gonna be pretty quick overall.

00:58

It's a rather basic command that I want you to

01:00

create just to apply these principles and that structure of

01:03

input, process, and output. And the specific command that you're

01:06

building for this exercise, I'm really excited for you to

01:09

do because we're covering some of the ideas that I've

01:11

talked about a bit in the last few videos, but

01:13

we haven't seen it in action.

01:15

Because what you're going to do is build a priming

01:17

command, but specific to priming the agent so understands how

01:22

to build tools into our AI agents like our Obsidian

01:25

agent. And so we'll be using the on demand layer

01:28

1 planning context that we created for this reference guide

01:31

on building tools and the principles that we have for

01:34

building tools. Super cool. And so it's gonna be kind

01:37

of like our more generic prime command we covered in

01:39

the last video, and you can actually use this as

01:42

a starting point. I would encourage you to do that.

01:44

But we're making it more custom to priming our coding

01:47

assistant for a specific

01:49

task type. And that's 1 of the things I hinted

01:52

as we can make these prime commands more dynamic through

01:55

parameters or just customizing the instructions to a specific task

01:59

type like you are doing here.

02:01

And so your task is to build this priming command

02:04

from scratch, and you can use this as a reference

02:07

if you want. You also can do it completely from

02:09

scratch. It's totally up to you. I want this to

02:10

be a very flexible exercise. And so this is how

02:13

you create the slash command in the cloud code. And

02:16

then for other any other AI coding assistant, remember that

02:18

you can just create a markdown document anywhere and then

02:21

just point the coding assistant to look there and take

02:24

on those instructions.

02:26

And I want you to specifically follow the input process

02:29

and output structure.

02:31

So think about what does the agent need to see

02:33

for the input section. Obviously, the guide to building tools,

02:36

maybe anything else you can think of. The process, what

02:39

should the agent do? Right? Like, read this file and

02:41

then understand key principles,

02:43

maybe do some additional research, like, whatever you want to

02:46

do for the priming to make sure that at the

02:48

end, it is going to understand your code base specifically

02:52

for building tools and then output a human readable summary

02:55

so that you can verify that it understands

02:58

the code base for this specific task type.

03:01

And so this is a structure you can use. So

03:03

you can use this

03:04

very shortened structure. You can use the other more generic

03:08

prime. Like, just take whatever you want as a starting

03:11

point.

03:12

And then before you write, think about a couple of

03:14

things. This is the last thing I have, and then

03:15

I'll send you off to do the exercise. Think about

03:18

what's the most important thing for the agent to understand.

03:21

How detailed should the output be? How will you verify

03:24

that the agent actually understood?

03:26

And then last but not least, when will you use

03:28

this command? And that all that context and, like, thinking

03:31

through those questions will really help you make the best

03:33

command possible. And then you can obviously test it by

03:36

just invoking the command, maybe even trying to build another

03:39

tool into the Obsidian agent if you want. You don't

03:41

have to take the exercise that far, but I'm leaving

03:44

it up to you to just get as much out

03:45

of this as you want. But I would really encourage

03:48

you to go and create this command. And then you

03:50

could, even if you want, take this further and build

03:53

your own planning,

03:54

execute, and commit commands as well. I want you to

03:57

start to build up your system and your library of

04:01

commands. And so go and do the first exercise right

04:04

now. Pause the video here, knock it out, and then

04:06

when you come back, I'll go over my solution to

04:09

exercise number 1. Alright. Welcome back. I hope that exercise

04:12

1 went really smoothly for you. So I just wanna

04:14

cover my solution now very quickly. And just like the

04:17

last exercise, I wanna be clear that this is an

04:20

example solution, not the correct answer. This is totally up

04:24

to you. It's your system. It's your code base. In

04:26

fact, I would encourage you to already do some tweaking

04:30

for how you know you wanna work or what your

04:32

project is. And so the main thing that I wanna

04:34

show here is just how I follow the input process

04:37

and output structure. And so I start by saying you're

04:40

about to work on building or modifying agent tools that

04:42

will be used by Pydantic AI agents. And I can

04:45

be pretty vague here overall

04:47

in this starting context because the global rules will cover

04:50

most of it. I just want a little bit of

04:51

an introduction here. And then, I'm going to have it

04:54

read the tool docstring patterns that we have in adding

04:57

tools guide. I'm going to at mention this so it's

04:59

gonna be included directly in the context for this command.

05:02

And so this is my input. Just nice and simple.

05:05

It doesn't have to be that complex for this priming

05:07

command. And then the process, this is the step by

05:10

step. I am basically just calling out each of the

05:12

things that I wanted to internalize. So it'll do the

05:16

analysis and read through the file in the way that

05:18

it can understand all of these things, telling it what

05:21

to pay special attention to, and then the report back

05:24

all of these core elements. And this is my output

05:28

section.

05:29

And I want it to do something that is very

05:31

human readable. So I'm saying 5 bullet points max. I'm

05:34

having it just give me the critical distinctions. Like, I

05:37

want this to be pretty concise overall. I wanna verify

05:40

understanding in 30 seconds because I am the 1 reviewing

05:43

the output here to make sure that when it goes

05:46

through this process, it really is understanding the code base

05:48

in the way that I need it to to implement

05:50

new tools into my agent. And so there you go.

05:54

That is the solution. Nice and simple for you. It

05:56

might look totally different and it might even be better.

05:59

But that's it for exercise number 1.

06:03

Now let's go on to exercise number 2. And so

06:06

I'm not having you create a command for exercise number

06:09

2. Rather, I want you to design the output structure

06:12

for the planning command. So you create the template

06:16

and then you can inject this to customize the planning

06:20

command that we covered in the last video.

06:23

And so going to that command really quickly just to

06:25

show you. The part that I'm talking about in particular

06:29

is the required plans sections. Right? Like, we have the

06:31

overview, relevant files, dependencies,

06:34

the step by step tasks to execute the plan. I

06:37

want you for this exercise to define for your plan.

06:41

What do you want those sections to look like? Because

06:43

remember, when I covered in the PIV loop the sections

06:46

we can have in a structured plan, I said this

06:48

is just a recommendation. And this does work really well

06:51

for me to have the task list and validation strategy

06:53

and goals, and you can take a lot of inspiration

06:55

from this. But this is just a starting point. You

06:58

can customize this however you want. That's what I want

07:00

you to do in this challenge. And so I even

07:02

have a starter template. If you scroll like halfway through

07:05

the read me for this exercise, I have a starter

07:07

template that you can copy and work from. So use

07:10

this. You can leverage an AI coding assistant to help

07:13

you create this as well, but really it's just like

07:15

layout each of the different sections, answer some of the

07:17

questions that I have in the template here.

07:20

And then 1 other reference you can use if you

07:23

want is you can take a look at the planning

07:26

prompts that I used in module 2. We went through

07:28

the PIV loop and I was typing things manually.

07:31

So just like the tools guide, I have that in

07:33

the exercise 2 folder for your reference. These are the

07:36

exact prompts that I used when I went through the

07:38

PIV loop with you in module 2. And the very

07:42

last prompt is 1 that I told you we were

07:44

going to be turning into a reusable prompt or a

07:47

command, and that is exactly what we are doing now

07:50

with the planning command.

07:52

And so this was a very long prompt. If you

07:54

remember back to module 2, I just, like, pasted this

07:56

in and I said, like, you don't have to expect

07:58

yourself to, like, type this entire thing out. But it's

08:00

the same kind of deal here where I describe the

08:02

file format, where I have the different sections that I

08:05

wanted to create in the structured plan, like the task

08:09

list and the user story and success criteria, the validation,

08:12

all of that. And so we have this example.

08:14

You also have the template that I just showed you.

08:17

So a lot of resources to get you started. And

08:20

so what you are creating

08:21

for, you know, the output of this exercise

08:24

is a planning output structure markdown document. And so it's

08:28

just the template that you can then inject into any

08:31

planning command.

08:33

So go ahead, spend 15 to 20 minutes, create your

08:36

own plan structure.

08:38

So pause the video here and then when you come

08:40

back, I'll go over my solution to this exercise. Alright.

08:43

Welcome back. You have the template for your structure plans

08:46

now, and so I'll go ahead and show you mine.

08:48

And, again, not the correct answer. But you can take

08:51

inspiration from this and see, for example, a level of

08:53

specificity that I have in the template here.

08:57

And so this isn't a structured plan. This is a

08:59

template for a structured plan. So for each of the

09:01

sections that I have here, I just have a couple

09:03

of bullet points for generally what I want the coding

09:06

assistant to fill in when it leverages this template

09:09

to build a structured plan. And it'll leverage this template

09:12

as a part of the planning command. So you got

09:15

the user story like we saw earlier, the problem statement

09:17

and solution statement,

09:19

relevant files that we wanted to reference. So it's kind

09:21

of like priming, but just like a very small version

09:24

because generally when we use the execute command on a

09:27

structured plan, it is a new conversation.

09:30

We have research documentation.

09:32

So just outlining, like, here is how you would add

09:35

some documentation

09:37

into the structured plan. So these are all fake links

09:40

because, again, this is just a template right now. And

09:42

then we have the implementation plan. What does it look

09:44

like to map out the phases or the tasks that

09:47

we need to knock out for this implementation? Right? We

09:49

got our task list right here.

09:52

And then we have our validation. So So the linting

09:55

and the unit testing and the integration testing, all the

09:57

core things that I told you is generally a part

10:00

of the plan because we want the coding assistant

10:02

while it's doing implementation to check its own work with

10:05

the things like unit tests, integration tests. So we got

10:08

that covered here as well. Very, very important to have

10:11

a good amount of detail for our testing strategy. And

10:13

then we have our acceptance criteria,

10:15

kind of like the success criteria,

10:18

that I've been referring to earlier. Just a different way

10:20

to name it, and I'm kinda doing that on purpose.

10:21

Right? Like, there have been a couple of different versions

10:25

of these, planning templates that you've seen. And I've done

10:28

that intentionally because I don't want you to get super

10:30

stuck to this 1 idea I'm sharing with you. I

10:32

really want you to customize it. So whatever you did

10:34

in this exercise, I hope you're happy with that because

10:36

you definitely could take your template here,

10:39

go into the planning command, and replace what I have

10:42

here with your own template, and then that can be

10:44

your planning command that you include in your system for

10:46

the rest of the course. And honestly, I think that

10:49

would be fantastic. So that wraps up the exercises for

10:52

this module. I hope this was really helpful for you

10:55

getting you started building your system, and we'll really get

10:58

into what it looks like to expand and leverage the

11:01

system, even automating and chaining our commands together in the

11:05

next modules. And even if you already had your own

11:07

system, you've been using coding assistance for a while. I

11:10

hope that you got some ideas to help refine things

11:13

with the mental models and the whole structure that I

11:17

covered with you, talking about goals in layer 1 planning,

11:19

what versus what goes in your commands. I hope this

11:22

was helpful. And so with that, I've got a bonus

11:24

video on command chaining coming up here, and then we'll

11:27

get into the next module, which is diving deep into

11:30

the planning phase of the PIV loop. And so the

11:32

next few modules will be getting into the PIV loop,

11:35

but really starting to apply our system. So I'm very

11:37

excited for that, and I will see you in the

11:39

next module for systems around planning.