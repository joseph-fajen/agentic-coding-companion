---
course: Dynamous Agentic Coding
module: 8
lesson: "8.1"
title: "Intro to GitHub for Agentic Coding"
type: lecture
status: raw
date_added: 2026-02-18
date_modified: 2026-02-18
tags:
  - dynamous
  - agentic-coding
  - module-8-github
  - github
  - version-control
  - remote-agents
key_concepts: []
prerequisites: ["7.4"]
related_lessons: []
---


Welcome to module 8 of the DynaMed agentic coding course.

00:03

We're gonna cover using AI coding assistance

00:06

remotely in our GitHub repository so we can spin off

00:09

tasks for our coding agents with our systems

00:13

to handle issues in our code and even review the

00:16

changes that we are making. And in the next module,

00:18

we'll take a lot of these ideas even further with

00:20

a fully custom system that I built for you that

00:23

allows us to do remote agentic coding with different coding

00:27

assistance in different platforms like GitHub still, but also Telegram

00:31

and Slack.

00:32

And all of that still does rely on GitHub as

00:35

the way to manage code changes and issues. And so

00:38

I'm introducing you to the ideas in this module. And

00:42

take a second to realize this. Going back to our

00:45

course schedule,

00:46

GitHub is the only tool that has made its way

00:49

into the title for 1 of the modules of this

00:52

course. I've purposely

00:53

avoided focusing on individual tools for the rest of the

00:57

course.

00:58

And even with AI coding assistance, I use Cloud Code

01:01

in all the examples, but I'm constantly talking about how

01:04

you can really use any AI coding assistant. But GitHub

01:07

is different. There are similar tools,

01:09

but it really stands above all the other ones, and

01:12

I'm using it for all of my agentic coding systems.

01:15

And so I owe it to you to create a

01:17

module dedicated to GitHub, and this is also going to

01:20

go very well into the next module on remote agentic

01:23

coding.

01:24

And by the way, I did change the order of

01:26

modules in the third release block here. If you look

01:29

back at the first video, you'll see that things are

01:31

a little bit different. But I wanted to do that

01:33

because these are the 2 very core modules of this

01:36

release block. And then the last 3 are still very

01:39

important and super useful, but these are the ones that

01:42

really show how we're going to continue to evolve our

01:44

system

01:45

from the first 2 release blocks. Because remember, we started

01:49

with manual prompting until we get confident enough that we

01:52

want to start to systematize things, creating our commands,

01:55

our on demand context, our rules, and now we're getting

01:58

into automating

02:00

our system. And so if you remember the bonus video

02:03

back in module 4 on command chaining, I showed this

02:06

in the workshop as well,

02:08

that's more of what we're doing now. So once you

02:11

are confident in your approach, like your prime plan and

02:14

execute commands and your structure plan, and you've iterated on

02:18

your system quite a few times, that's when we can

02:20

get into this third release block. So don't just jump

02:24

right into what I'm showing you in modules 8 and

02:26

9. Because we're gonna do things kind of like the

02:28

command chain where we take a lot of the commands

02:30

in our system and we automate them. We string them

02:33

together. So a single request in GitHub will kick off

02:36

an entire PIV loop. And the same thing with the

02:39

application I'll show you in the remote agent decoding module.

02:42

So we unlock a lot of autonomy and a lot

02:45

of power here, but we're taking ourselves out of the

02:48

loop, at least in some ways. Now I've been pretty

02:50

crafty about how we can be in the loop in

02:52

this next module. I'm actually really excited for this 1,

02:55

but especially here, I wanna show you what it looks

02:57

like to have the coding assistant take care of a

03:00

PIV loop completely end to end just through a simple

03:02

request that we send off in GitHub. So do this

03:06

once you're confident in what you've created here. So with

03:10

that, let's get into GitHub. Now you might be asking,

03:12

Cole, why is GitHub the 1 tool that's made it

03:15

into a module title? Let me explain.

03:18

So right now, there is a big myth going around

03:21

that AI coding assistants are going to get to the

03:23

point in the future where we just need a single

03:26

chat input, a single magic box where we tell the

03:29

AI coding assistant what we want it to build, and

03:31

it gets it right every single time. And I firmly

03:35

believe that no matter how powerful coding agents get, this

03:38

is just not going to exist.

03:40

And the reason for that is we're always going to

03:42

need what I like to call the orchestration

03:45

layer. We need a place to manage tasks for coding

03:48

agents, to track changes, version control,

03:51

assign tasks to different coding agents because it's probably not

03:54

just gonna be 1 in the future. We need all

03:57

of these things. And a tool like GitHub

03:59

is the perfect

04:01

platform for this, the control center for our AI coding

04:05

assistance. And in this module, I'll show you exactly what

04:08

I mean by that with a lot of different examples,

04:10

even integrating with our systems.

04:13

And I'll show you in this video right now a

04:15

few different approaches that I have for using AI coding

04:19

assistance

04:19

right in GitHub. And so we'll integrate cloud code, codecs,

04:23

and cursor

04:24

directly in our GitHub repos to help us handle issues

04:27

and pull requests

04:29

using GitHub actions, and I'll explain that as well.

04:32

And so I've covered this a little bit on my

04:34

YouTube channel, but I'm gonna dive deeper with you and

04:37

show you how we can integrate our systems, like kicking

04:39

off a PIV loop from GitHub.

04:42

So over to our Obsidian agent now. Of course, I

04:44

chose this as the example for integrating coding agents directly

04:47

in our GitHub repos.

04:49

And I'm about to explain some different concepts with Git

04:53

and GitHub.

04:54

And if any of it is overwhelming to you, I

04:56

will link to my Git and GitHub workshop that I'm

04:58

doing in the description so you can check that out

05:00

to learn from absolutely the ground up. But there are

05:04

3 core concepts we have with GitHub repositories.

05:07

We have our commits, that's our version control. We have

05:11

issues and we have a pull requests.

05:14

And so commits, these are the incremental changes we make

05:17

to our code base. So we can track how our

05:20

code has evolved over time looking at what are called

05:23

diffs, like here are the things that were added, here

05:25

are the things that were removed in this specific commit.

05:27

We can also revert back to any state of our

05:30

code base through going back to 1 of these commits.

05:33

So very, very powerful. Then we also have issues. Issues

05:37

is the place for us to

05:39

request changes to their code base, like any bugs that

05:42

we find or any enhancements that we want to make.

05:45

And I have a couple of super basic examples here

05:47

for,

05:48

the demonstration. And then last but not least, we have

05:51

pull requests. Pull requests is our way to propose changes

05:55

to our code base. So typically in a GitHub repository,

05:58

you will have your primary branch usually called main. This

06:01

is where you have the stable version of your code

06:03

that you have deployed to production. And when you want

06:06

to make a change

06:08

to your code base, a new feature or a bug

06:10

fix, you'll typically do that in a separate what's called

06:13

feature branch. And then when you're ready to bring that

06:16

into main and deploy to production, you'll create a pull

06:19

request where you're essentially proposing

06:21

changes to bring into main. Right? Like, I wanna take

06:25

this fixed branch and put it into main. And this

06:28

is also where we can do a review of the

06:30

code before we do the merge.

06:32

And the reason I'm telling you all this is because

06:34

in the next few videos, I'll show you how to

06:37

trigger AI coding assistance

06:39

when these events take place. And we're gonna do it

06:41

with, like I said, cloud code, codex, and cursor just

06:44

to show you that really any AI coding assistant can

06:47

be built into this process.

06:48

So I'll show you an example. Go to the issues

06:50

here to the 1 where I'm asking to make the

06:53

read me more concise just as a simple example. So

06:55

I create this issue and then take a look at

06:58

this. I can mention my different coding assistants

07:01

to trigger them to handle this issue and even propose

07:05

a change. So bringing their branch into main through a

07:07

pull request. So here is cloud code and then we

07:09

have cursors fix and then we have codex. And I

07:12

ran all 3 of these in parallel by the way

07:14

and I'll show you how to do all of this.

07:15

It's super cool and actually surprisingly simple. And then not

07:19

only can we handle issues, but we can also handle

07:22

pull requests. And so we can review the code that

07:25

is proposed here. So for example, this is a pull

07:27

request from codecs

07:29

to make the read me more concise, and I ask

07:31

Cursor to perform a comprehensive code review. This is the

07:34

output that we got here. Things are looking pretty good,

07:36

but this is so cool that I have this kind

07:38

of AI dev team integrated right in my GitHub repo,

07:41

able to handle issues and pull requests even working together.

07:44

Like, this kind of orchestration layer, I think, is always

07:47

going to be important. And that's why I'm saying that

07:49

we're never gonna have this single magic box. We need

07:51

a tool like this as our orchestration layer. Okay. So

07:54

this is great, but how are we even triggering our

07:57

coding agents?

07:58

Where are they running? I mean, it's definitely not on

08:00

our computer locally. That wouldn't even be remote agent to

08:03

coding after all. Well, that my friend is where GitHub

08:06

actions comes in, and this is so powerful. It's 1

08:09

of the reasons that I love GitHub.

08:11

Because actions is a way for us to essentially run

08:14

serverless

08:15

jobs that are triggered by the different events in our

08:17

GitHub repository.

08:19

I'll show you an example here of all the success

08:21

jobs.

08:22

So cloud code review, or we have our different fixed

08:25

ones like cursor fix and codex fix. All these jobs

08:28

are triggered and run as GitHub actions. And the best

08:31

part is GitHub actions are completely free, and GitHub spins

08:36

up a little environment to handle each job or each

08:39

action, and then tears it down once it's complete. So

08:42

it basically scales to infinity, and I can run all

08:45

these things in parallel

08:46

as well. And each 1 of these jobs that I

08:49

run-in GitHub actions, I just have to define as what's

08:52

called a YAML file within my repository. So I'm version

08:55

controlling my jobs just like I'm version controlling my code

08:59

base. YAML is kind of like JSON. It's more configuration

09:03

versus code, but you can also write code in the

09:06

steps that you wanna perform for your job. And so

09:10

you always will put your workflows in the dot GitHub

09:13

slash workflows folder. That is where GitHub actions looks for

09:17

when it wants to figure out, like, okay, when there's

09:19

a new issue comment, are there any actions that I

09:22

need to trigger. And so at the top of every

09:25

single GitHub action workflow,

09:27

you're gonna have something like this that specifies when we

09:29

are going to run this job. Is it gonna be

09:31

on a new issue comment or a pull request comment?

09:34

Is it gonna be when there is a new commit?

09:36

You get to define that. And then the jobs here,

09:39

this is a list of everything that you want to

09:41

run-in the GitHub action workflow. And so for example, this

09:44

clod fix, which I'm gonna go into this in a

09:46

lot more detail in the next video, what we do

09:48

here is first we limit the users that can trigger

09:52

this. So we can have this in a public repo

09:54

but it's not like everyone can use our anthropic subscription

09:57

and leverage our clod code. And so if the permission

10:01

check passes,

10:02

then we're going to check out the repository so we

10:04

have the code base available in this environment that GitHub

10:07

spins up for the action, and then we're going to

10:10

load in the instructions. And so we're going to bring

10:12

in a prompt template. This is a part of our

10:15

system that we want to run against cloud code in

10:18

this action. And then to actually kick off Cloud Code,

10:21

it's only a few lines here because Anthropic has an

10:24

official Cloud Code action. So we have extensions

10:28

or tools that we can bring in as 1 of

10:30

the steps in our jobs. And so we're calling the

10:33

cloud code action

10:34

and then we're passing in our secret which I'll show

10:37

you how to set that up in GitHub for our

10:39

cloud token and then the custom instructions that we just

10:42

pulled from a file in our source control. And then

10:44

we just handle with an error message if there's anyone

10:47

who's not authorized to invoke

10:49

our cloud code agent.

10:51

And that's really simple overall. Like, it's really just a

10:54

little bit of code, a little bit of configuration defining

10:56

what the step by step process looks like whenever there

10:59

is a new issue

11:01

comment or a new pull request comment. And specifically, we're

11:04

looking for that tag there of at claud dash fix.

11:07

So if it's not an issue comment or pull request

11:09

comment, if it's any other action in GitHub, we will

11:12

immediately filter out from running this job. Or if it

11:15

doesn't have at claud fix at the start of the

11:18

comment, we will also filter out this job. And so

11:21

that's pretty much what it looks like for all of

11:23

the different actions that we have here. And by the

11:25

way, it's really easy to use AI coding assistance to

11:28

help you build these workflows as well because GitHub is

11:31

such a popular tool. It's been around for so long.

11:35

AI coding assistance know this sort of structure

11:38

like it's on the back of their hand. And if

11:40

you want another resource to dive even deeper into GitHub

11:43

actions, I cover it very extensively

11:45

in module 6 of the AI agent mastery course. And

11:48

here, the trigger is when there is a new commit

11:51

versus an issue or pull request comment because this is

11:54

a more

11:55

standard usage of GitHub actions where whenever there is a

11:58

commit, we have all these checks that we want to

12:00

run like running our unit tests, building the containers,

12:03

doing our linting and security scanning, making sure all those

12:06

things are good before we deploy to production.

12:08

But this is another example to just show that GitHub

12:11

actions are very simply a way for us to run

12:14

a bunch of steps when something happens in our repository.

12:18

So the very standard example that I just showed is

12:20

something like we make a push to a GitHub repo

12:22

and then GitHub actions will run in this isolated environment

12:26

to go through these checks to make sure that our

12:28

code base is ready to deploy. And then in our

12:31

case, we're doing things a little bit differently where the

12:33

step by step process is leveraging a coding assistant for

12:36

something in our repo, and I think that's honestly a

12:38

lot more exciting.

12:39

And now you might think that once we have these

12:41

YAML files for our jobs, there's gonna be some super

12:45

complicated configuration to make it so they're set up in

12:47

our repo, but there's really no configuration at all except

12:50

for the secrets that I'll show you in a little

12:52

bit. So all you have to do is just take

12:54

the YAML files that you have in your dot GitHub

12:56

slash workflows folder, and you just have to push it

12:59

into your GitHub repo. That's it. Now all of these

13:02

jobs are immediately available to be triggered based on the

13:04

events that we have defined here. GitHub automatically picks up

13:08

everything that we have in this folder specifically. And so

13:11

now when I make an issue comment or a pull

13:13

request comment and I have claud fix, it'll trigger this.

13:16

If I prefix it with codex fix, like at codex

13:19

fix, it'll trigger this 1. They are already good to

13:21

go. We just have to set up our secrets now

13:23

and then I'll give you a quick demo here. So

13:25

to set up your secrets, you go into the settings

13:28

for your repo, scroll down to secrets and variables, and

13:30

click on actions.

13:32

And so just based on the secret that your workflow

13:35

is looking for, you just have to set this right

13:36

here. For example, in the Cloud Fix 1 that I

13:38

was showing you earlier, we are looking for secrets dot

13:41

cloud code OAuth token. So this corresponds exactly to this

13:44

value, and GitHub will pull that in automatically

13:47

when you reference it like that. And by the way,

13:49

the way that you get this claud code OAuth token

13:51

is once you have claud installed and authenticated on your

13:55

local computer, you can run the claud setup dash token

13:58

command. This is going to give you a token that

14:01

lasts for, I believe, a year. So it's a long

14:03

standing token that you can plug into your GitHub repo.

14:05

For your cursor API key, you just get that from

14:08

the integrations

14:09

tab in your dashboard. So I have my key created

14:11

here. And then for OpenAI, you just get that from

14:14

platform dot open a I dot com slash api dash

14:17

keys. And so I'm showing you how to use all

14:19

these different coding assistants in GitHub. So I have all

14:22

these credentials set up here. Each 1 of these is

14:24

referenced in 1 of those YAML files, and I'll show

14:26

you a lot more in the next video how we're

14:28

using each 1 of these coding assistants specifically. But that's

14:31

it. And then the 1 other thing you might need

14:34

to do depending on your repository

14:36

is allow for these coding assistants to make pull requests

14:39

because we want them to do that when they're handling

14:41

issues. And so you do that by going to the

14:43

actions tab here, clicking on general,

14:46

scrolling down, and making sure that you have this box

14:49

ticked, allow GitHub actions to create and approve pull requests.

14:52

And if this is a repo in the organization, like

14:55

a GitHub organization, you might have to go to the

14:57

organization level and enable the same thing. So I just

15:00

wanna get those little details out of the way for

15:02

you so that you can follow along with this end

15:04

to end because you can use this all yourself

15:06

right now. Like, I didn't make any of this specific

15:09

to the Obsidian agent repo. So if you take the

15:11

dot GitHub workflow folder and you bring it into your

15:14

own repository with all of the jobs and also the

15:18

prompt templates that I'll explain more in the next video,

15:20

you could use this immediately. You just have to set

15:22

up the secrets like I showed you or maybe you

15:24

could, like, just pick cloud code or just pick codex

15:26

and set that single secret, and then you're off to

15:29

the races. I'll even show you a quick demo right

15:31

now of 1 of these, and then in the next

15:32

couple of videos, we'll see a lot more of this.

15:34

So I can go into 1 of these pull requests

15:36

like this 1 right here, and, oh, we don't actually

15:38

have a review on this 1 yet. Shoot. Well, we

15:40

definitely want to review any pull requests before we merge

15:43

into main. And this is a fix done by cursor

15:46

so let's go ahead and have Claude code review. So

15:48

I'll do at Claude dash review. That's the trigger for

15:51

1 of my jobs that's waiting for a pull request

15:54

comment. So boom. I'll comment this and then in just

15:56

a second here, we'll see the workflow start. We can

15:59

go into the actions and watch for this as well.

16:01

So I can filter for any that are in progress,

16:04

and it takes a little bit to start usually. So

16:07

I'll refresh once, and there we go. A couple of

16:09

seconds later, and we have it

16:12

in progress. And so you can click into this to

16:14

view the log. So there's quite a bit of visibility

16:16

into this as well. And then going back to the

16:19

pull request, I can just wait for it to finish.

16:21

And we can see that Cloud Code even gives us

16:24

a message here saying that it's in process.

16:26

And there we go. Our review completed in only a

16:29

minute and things are looking fantastic. We can also go

16:32

back to the action logs and click into it to

16:35

see what happened with each 1 of our steps, which

16:37

is especially useful if there is any kind of failure.

16:39

So I can click into the big 1 here where

16:41

we run the actual Cloud Code review. We can see

16:44

the full prompt that we sent in, all the tool

16:46

calls and its output. Very nice to dig into that.

16:49

But, yeah, at a high level, this is the main

16:51

thing I care about and the review was successful.

16:54

And so there you go. In the next video now,

16:56

I want to show you specifically how the workflows are

16:59

designed for handling issues both with bugs and enhancements.

17:03

And the cool thing here is that a lot of

17:05

the system

17:06

that we built in the last release block, we're gonna

17:09

be using here. And so when we address an enhancement,

17:12

we're gonna go through a complete PIV loop. And then

17:15

when we address a bug, we're gonna use the RCA

17:17

and implement a fixed commands that I also showed you

17:19

in modules 4 and 7. And there are some different

17:23

approaches that I want to show you. So how we

17:25

can use coding assistance in different ways

17:28

depending on how autonomous we want the coding assistant to

17:31

be. And so there's a couple of different workflows just

17:33

to help you think about how you integrate coding assistance

17:37

into your GitHub repo. So that's in the next video.

17:39

Really excited for that. So I will see you there.