---
course: Dynamous Agentic Coding
module: 2
lesson: "2.3"
title: "Implementation - Structured Plan Execution"
type: lecture
status: raw
date_added: 2026-02-18
date_modified: 2026-02-18
tags:
  - dynamous
  - agentic-coding
  - module-2-piv-loop
  - implementation
  - structured-plan
key_concepts: []
prerequisites: ["2.1", "2.2"]
related_lessons: ["2.4", "6.1"]
---


Now it's time for the fun part. We finished with

00:02

our planning. We're ready to move on to implementation,

00:05

having our coding assistant write the code. Now let me

00:08

be very clear here. You are only ready for this

00:12

stage once you have fully validated your plan.

00:15

Remember, the goal here is to get on the same

00:17

page with the AI coding assistant for what you want

00:19

to develop with the success criteria and the task list.

00:22

You wanna be meticulous

00:23

about analyzing all these things and making sure that looks

00:26

good to you, and then only then are you ready

00:28

to let it go with this plan. Because remember, when

00:31

I covered the PIV loop initially, I talked about how

00:34

we very much wanna be a part of the process

00:36

during both the planning

00:38

and the validation.

00:39

It's only the implementation

00:41

that we're trying to delegate almost entirely or entirely

00:45

to the AI coding assistant, which by the way, that's

00:47

also why this video is 1 of the shorter ones

00:50

because we have most of the structure in place from

00:52

the planning. So we're just gonna let the AI coding

00:54

assistant rip and be a part of the process at

00:56

least a little bit to trust but verify.

00:59

But, really, most of the verification comes in the next

01:02

video when we cover validation in more detail. So at

01:05

this point, we have our structured plan. And just as

01:07

a really quick recap here, layer 1, our project planning,

01:11

The primary output for this was our global rules, the

01:15

primary instructions that we want our coding assistant to always

01:18

follow. So I covered that at a very high level

01:21

in the last video, a lot more on this in

01:23

module 3. These are the global rules that I have

01:26

for my project here. And then for our layer 2

01:28

planning, this is where we created that coding prompt markdown

01:31

document.

01:32

And that's what we're going to execute right now. So

01:34

I hope that makes sense. Layer 1 is our global

01:36

rules. It's a single markdown document as an output. And

01:39

then layer 2, the single markdown output is our structured

01:43

plan. That's a little bit of a simplification, but that's

01:45

just the good mental model here. Global rules, plan. Now

01:49

we move on to implementation.

01:51

And this is going to be pretty straightforward. Going to

01:53

our AI coding assistant, we go into, like, cloud code,

01:57

for example, and now we just start a brand new

01:59

conversation because this

02:01

structured plan that we created here is all of the

02:04

context we need. We don't even have to do any

02:06

priming

02:07

on the code base here

02:09

because we're calling out folders and files to look at

02:11

already within our structure plan.

02:14

And 1 quick thing before we get into implementation here.

02:17

Generally, what I like to do after I create my

02:20

structure plan is I will make sure that it's in

02:23

a neat folder where I'm organizing all of my plans.

02:26

Like, typically, I'll create a folder called requests, something like

02:29

this. This is totally up to you how you wanna

02:30

organize your requests. But a lot of times, I like

02:33

to actually

02:34

check-in my plans to source controls so that I can

02:37

have a record of all the structure plans that I've

02:39

used to implement features throughout my code base. And so

02:42

within Git or GitHub Desktop,

02:44

you can check-in this plan before you go into implementation

02:47

or just ask the AI coding assistant to check,

02:50

my plan

02:51

into git. Right? Something like that. Just a super simple

02:53

prompt so that that way your code base is in

02:56

a current save state here where we're ready to implement

02:59

the feature. We have the plan, but we don't have

03:01

any code yet. So that way if your coding assistant

03:03

messes up in the implementation that we're just about to

03:06

get into, you can revert everything

03:08

back to when you have your plan and then you

03:10

can try again. So even worst case scenario, your AI

03:13

coding assistant completely botches the implementation here. We'll just revert

03:17

things. I'd highly recommend

03:19

using Git, like, having all of your code bases set

03:22

up as repositories so you can manage versions and backups

03:24

of things like that. Now for the actual implementation, let

03:27

me go ahead and paste in a very simple prompt

03:29

that I'll use here. Just telling it to read the

03:31

structured plan and execute it task by task, making sure

03:35

that I cover everything for the validation as well because

03:38

this is gonna automatically be a part of our structured

03:41

plan.

03:42

And I know this is a pretty roughly crafted prompt.

03:46

There are definitely better ways to prompt for execution here

03:49

to read our structured plan and execute it step by

03:52

step. But I'm doing that intentionally

03:55

because in 2 modules from now, when we get into

03:58

reasonable prompts,

03:59

we're gonna take ideas around this as well as planning

04:02

and priming. We're gonna start to build those workflows that

04:05

we create

04:06

as our system. And so we'll get there when this

04:09

becomes a lot more elaborate. But right now, I'm just

04:12

covering the basics. The principles are super important for us

04:16

to focus on here, then we'll get into automating and

04:19

systematizing things. But right now, this is gonna get the

04:22

job done, especially because what I'm asking for, I already

04:26

have so much structure

04:28

within my global rules and my prompt, and it really

04:32

knows my code base well. Like, that's 1 of the

04:33

things that I'm confident in through the whole planning phase.

04:36

So I'm gonna go ahead and send this in, and

04:38

we'll be off to the races. Alright. So I'm back

04:41

mid execution because I wanna talk about a couple of

04:43

things as we see it going live. So first of

04:45

all, it read our structured plan.

04:48

It read through some of the files that we call

04:50

out in the plan. So it's finding integration points, for

04:52

example, like where it has to go and actually update

04:54

things to add in this new feature. Like in this

04:56

case, the new tools that we're adding into our Obsidian

04:59

agent. And then there we go. It's already going and

05:00

making some changes here within our existing code. So this

05:04

is phenomenal.

05:05

And this is gonna go for quite a while. Depending

05:08

on the complexity of the feature that you're building, this

05:10

could be 20 minutes, 30 minutes. I've even seen an

05:13

hour before,

05:14

especially because we had the validation that it'll run as

05:17

well. So it'll create the test and iterate on those

05:19

at the end

05:20

of our plan execution here. And I hope that you

05:23

can see, like, when this goes for a while, it

05:26

very much proves my point that we're not that much

05:29

in the loop for the implementation. We really are just

05:32

letting it rip for quite a while here. And the

05:35

only reason we're able to do that is because of

05:38

how much we put into the planning.

05:40

And we know that we can trust it because we

05:43

are verifying it after. Right? So like, that's that's the

05:46

thing I wanna tell you here is that we're not

05:49

vibe coding. Because even though the implementation goes for a

05:52

very long time, it is sandwiched between 2 parts of

05:55

the process that we are super involved with. And that

05:59

is the only reason also that we're able to use

06:02

this process to do pretty complex implementations.

06:05

Like, what I'm doing right here is actually relatively basic

06:08

to what you're able to get an AI coding assistant

06:10

to do in a single shot. And the big question

06:14

you're probably having right now is, well, how complex of

06:17

a task can I really do in a single shot?

06:21

And really, it depends on 2 things. It depends on

06:24

your code base, like how well structured your code base

06:28

is for AI coding assistance. More on that in the

06:30

next few modules. And then it also depends like how

06:33

good your planning process is. Like how much did you

06:36

really reduce the assumptions

06:38

the AI coding assistant, needs to make based on your

06:41

structure plan?

06:43

And, yeah, I'll say that this is really a muscle

06:46

that you'll grow over time. As you're using AI coding

06:49

assistance,

06:50

you really start to get a sense of what they're

06:52

able to handle and what they can't. And then as

06:54

new large language models come out or new AI coding

06:57

assistance come out that are better, you'll experiment with those

07:00

and you'll kind of expand your muscle. Like, you'll you'll

07:02

adjust the muscle to adapt to those new tools and

07:05

LLMs. And so, yeah, it's the kind of thing where

07:07

like I have a general idea. Like if you give

07:09

me any idea for any project, I can think to

07:11

myself pretty quickly like would I be able to do

07:14

this with a single PIV loop iteration?

07:17

Or would I have to do a couple and really

07:19

break up the task? And that's just a muscle that

07:21

I've grown over time. You definitely will as well. So

07:24

my encouragement to you is just try to do the

07:27

PIV loop for all these features you want to build

07:30

and just start to get that sense of what it's

07:32

able to accomplish

07:33

versus what you might want to split up into smaller

07:36

tasks. And that always is a solution by the way.

07:38

When it really starts to trip up on something, just

07:40

think about how you can split it up into smaller

07:42

tasks. Like this right here, I'm really just creating a

07:45

single group of tools. It is a very granular task

07:49

overall. Okay. So I came back 5 minutes later and

07:52

we are already in the validation phase of our structured

07:55

plan, and that's for the next video. So really, we've

07:57

done everything that we need to for this video. I

08:00

told you it would be short. We've done all of

08:02

the code changes that we need except for anything that

08:05

it might do as it iterates on its own work.

08:07

Very, very cool.

08:09

The last thing that I wanted to show you, going

08:11

back to our initial prompt here,

08:14

anytime we have a kind of step by step process

08:17

or any sort of standard operating procedure that we're gonna

08:20

be using time and time again for a AI coding

08:22

assistant, that definitely screams

08:25

turn this into a reusable workflow. This definitely is 1

08:28

of those prompts that we're going to make more elaborate

08:31

and then turn it into a reusable workflow in 2

08:33

modules from now so we never have to type it

08:35

out again. Because really, we have this predefined workflow

08:39

to operate on a structured plan that's never really going

08:42

to change. So we wanna point our coding assistant to

08:45

this prompt,

08:46

point it to the structured plan, those 2 things together,

08:49

and then we let it rip like we're doing right

08:51

now, but we can do it in a much more

08:53

elaborate and automated way. That's the system that we're going

08:56

to get into. So the next time, by the next

08:59

time, I go through the PIV loop with you again,

09:02

we're gonna be doing it to create this Obsidian agent

09:05

completely from scratch. Because at this at that point, we're

09:08

gonna have covered rules in a lot more detail. We

09:11

will have created our first reusable prompts, our first workflows

09:15

and systems. We're gonna apply all of that. And so

09:17

principles now, systems coming very soon. So you get to

09:21

see just a taste of what that's gonna look like,

09:24

the kinds of things that we can automate and turn

09:26

into commands like this. And so with that, that's everything

09:30

that I have for implementation. So in the next video,

09:33

it looks like this is done here. So I'll in

09:34

the next video, I'll go over what it did for

09:36

validation and then I'll show you how we can be

09:39

a part of the validation process as well. Very important.

09:42

So I'll see you over there for that.