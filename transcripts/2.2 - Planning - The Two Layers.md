---
course: Dynamous Agentic Coding
module: 2
lesson: "2.2"
title: "Planning - The Two Layers"
type: lecture
status: raw
date_added: 2026-02-18
date_modified: 2026-02-18
tags:
  - dynamous
  - agentic-coding
  - module-2-piv-loop
  - planning
  - layer-1-planning
  - layer-2-planning
key_concepts: []
prerequisites: ["2.1"]
related_lessons: ["2.3", "5.2", "5.4"]
---


Now is our time to see the planning part of

00:03

the PIV loop in action. Now we're even gonna be

00:05

building on top of the primary agent for the course,

00:08

the Obsidian

00:09

second brain assistant. So I'm very excited for that. Here's

00:12

how this video is going to go. First, I'll introduce

00:15

you to the Obsidian Assistant since it is the first

00:18

time that you've seen it. And then with that, we'll

00:20

get right into the planning.

00:22

And so I'll explain why more in a little bit,

00:24

but we're just gonna cover layer 1 with the project

00:27

planning very quickly in this video, establishing the rules that'll

00:30

dictate how our AI coding assistant operates. And then most

00:34

of this video is going to be focused on layer

00:37

2, our task planning, because we're gonna be building a

00:40

simple feature on top of our Obsidian Assistant in the

00:43

next few videos here because that's going to give us

00:46

the best introduction to the PIV loop and seeing it

00:49

in action without getting too in the weeds.

00:51

And so when we are in our Vy planning stage,

00:55

we are going to simply, like I said in the

00:57

previous video, explore ideas with the AI coding assistant, establish

01:00

an understanding

01:02

with what feature we want to build, and it is

01:04

not structured at this point. And so as I give

01:07

you an example of Vibe planning, you can take inspiration

01:10

from that. But this is where it's really up to

01:12

you. Just having a casual conversation

01:15

with your AI coding assistant. And then I'll show you

01:17

what it looks like to turn that conversation

01:20

into a structured plan following the 4 pillars of context

01:23

engineering.

01:24

The output of layer 2 is a markdown document,

01:27

a single document that has our goals, success criteria, documents,

01:31

and task lists. We'll have all that to bring us

01:34

into the next video where we use that structure plan

01:37

for implementation in a brand new conversation

01:40

with the AI coding assistant. Now let me be very

01:43

clear on something here. Right now, we're not doing anything

01:46

with systems or workflows

01:48

yet. We will very soon. Don't worry. But we are

01:52

intentionally

01:53

not covering

02:03

mental energy into structuring things so we're not throwing too

02:07

much at you at the same time. So I wanna

02:09

cover the core of PivLoop. Right now, we're gonna do

02:11

barely anything with global rules. We're gonna do nothing with

02:14

commands, and we're just building a simple feature on top

02:16

of the agent focusing on layer 2. In the next

02:19

couple of modules, that's where we'll really get into rules

02:22

and and commands and creating the first version of our

02:25

system. We'll even build the Obsidian agent completely from scratch

02:28

so you can really see what it looks like to

02:30

optimize a code base to work with AI coding assistance.

02:34

So we'll get to the more fancy stuff soon, but

02:36

right now in the next few videos, I just wanna

02:39

make sure that you really, really grasp the fundamentals. No

02:42

matter if you're new to AI coding or if you

02:43

already have a process yourself, I just wanna make sure

02:46

that we're really on the same page here. And that

02:48

is also why we're not focusing very much on layer

02:51

1 right now because we're doing that a lot in

02:53

the next module.

02:54

And also, as I am typing or speaking, more on

02:58

that in a little bit to the AI coding assistant,

03:00

we're not doing anything with our commands at this point.

03:04

No reusable prompts.

03:06

And that's actually part of the exercise I have for

03:08

you. As you go through this video with me, think

03:11

about all the things that I'm typing out or talking

03:13

to the AI coding assistant and think about what we

03:16

would want to turn into a reusable work flow. The

03:19

kinds of things you probably find yourself typing a lot

03:21

or just more of the longer prompts that you definitely

03:24

would wanna create yourself every single time. So take that

03:27

as an exercise as we go through this, but right

03:29

now, no commands. I'm gonna be just working in the

03:32

AI coding assistant directly, going through the planning process.

03:35

Now before we get into the planning, I wanna very

03:38

quickly introduce you to our Obsidian agent. And when I

03:41

say quickly, I really mean it because we are gonna

03:43

be covering it a lot more together in the next

03:46

few modules when we build it from scratch. But right

03:49

now, this is the agent that we're building on top

03:51

of for this first demonstration of the PIV loop,

03:54

and this is a freaking awesome agent that you can

03:56

use immediately. I'll have a link in the description for

03:59

you to download it and try it out yourself. Not

04:02

only did we pick this agent because it's a good

04:05

use case to demonstrate the power of AI coding assistance

04:07

in this course, but also because it's super practical. It's

04:10

an agent that helps us manage our local notes and

04:13

knowledge in Obsidian.

04:15

So this is the ReadMe that we're looking at right

04:17

here. We describe the different tools that the agent has

04:20

access to. We followed all of the principles that I

04:22

cover in the AI agent mastery course of Dynabas as

04:25

we built this, and you'll see that more the next

04:27

modules as well. And then we got a quick start.

04:30

Very, very easy to get this agent up and running.

04:32

You can pick from different LLMs.

04:34

So you can pick, you know, the engine behind the

04:36

agent. And then there's instructions for getting incorporated into Obsidian

04:40

as well. So specifically, we are using

04:43

the Copilot

04:44

plugin within Obsidian.

04:47

And when you use the Copilot plugin, you can create

04:49

custom models. You can look at the documentation

04:52

for this if you want, but these are my settings

04:54

for connecting the Obsidian agent that I have up and

04:57

running in my terminal

04:59

into my Obsidian vault through the Copilot extension. So it's

05:02

running on local host port 80 30 by default. And

05:05

so now what I can do with the Copilot plugin

05:07

is I have this chat widget on the right hand

05:09

side that I can open up. And then when I

05:12

select my LLM, I can select my custom agent decoding

05:16

course agent. And take a look at this. I can

05:18

talk to it just like any old LLM in a

05:21

chat window, but it has all these tools that help

05:23

me manage my Obsidian. So I can have it say,

05:26

let's just say a search for,

05:28

personal AI automations. I can have it find this file

05:31

that I have open up in Obsidian right now. So

05:33

it's gonna use the tool to search my vault. There

05:35

we go. It found the notes, and I'm gonna say,

05:37

summarize this for me. And don't notice how fast the

05:41

responses are. Like, this is a blazing fast agent, which

05:43

is 1 of the things that we prioritized here. And

05:46

it can also update notes as well. I can say

05:48

add another

05:50

automation

05:51

at the bottom. So there's a tool specifically to append

05:54

content to the bottom of a file. It can also

05:56

patch throughout a file as well. Please provide the details

05:59

or description of a new automation. I'll just say make

06:01

1 up here. I just wanted to add something random

06:03

to the bottom here. So in a second, we'll see

06:05

a pop up and boom. There we go. A habit

06:07

tracking and motivation.

06:09

Alright. Super cool. So just a super quick demonstration of

06:12

the agent. Throughout this course, we're gonna be adding a

06:14

lot more tools and capabilities to this agent as well.

06:18

So yeah. Definitely a lot more coming for this agent.

06:20

It's gonna be a resource to go along with everything

06:23

else we've got in the course for you. So with

06:26

that, let's now think about adding more capabilities to this

06:30

agent as our first demonstration of the PIV loop. Alright.

06:33

So now on to the planning. If you're using Versus

06:36

code like I recommended or some fork like cursor or

06:38

windsurf, you can do a control j or command j

06:41

in Mac to open up a terminal right within your

06:43

IDE. And then now we can go ahead and just

06:45

run whatever AI coding assistant we have. Like, I'm gonna

06:48

be using cloud code throughout this course. All of the

06:51

prompting and everything in this video will apply no matter

06:53

your coding assistant. And 1 other tip really quickly

06:56

is if you add in the dangerously skip permissions flag,

06:59

Cloud will no longer ask for my permission to do

07:02

anything like editing any of my files. And so I'm

07:04

gonna do this just for the sake of brevity. I

07:06

wanted to 1 shot through all of the prompts that

07:08

I give my coding assistant here. And so the first

07:11

thing we're going to do is layer 1 planning. And

07:14

again, we're not gonna cover this in a lot of

07:16

detail right now because the primary output of project planning

07:21

is your global rules. This is the stable resource that

07:24

we're really gonna dive into in the next module.

07:28

This is the context

07:29

that is always loaded into your AI coding assistant, and

07:32

so this is where you specify

07:34

all of the top level rules. You you want your

07:37

coding assistant to follow

07:39

absolutely no matter what.

07:41

And so within the folder for this video that I'll

07:44

have linked to below,

07:45

I have a document here just outlining my recommendations for

07:48

the sections to have in your global rules. And this

07:51

kind of speaks to the higher level principles that you

07:53

wanna focus on here. Things like the core principles like

07:56

KISS or YAGNI. You can have your coding assistant help

07:59

you research these. Your tech stack decisions like what are

08:02

the tools and libraries that I want to use for

08:04

my implementation.

08:05

My architecture patterns, documentation standards,

08:09

logging rules, testing patterns, and if there's anything that you're

08:12

unsure of here like maybe you're newer to coding and

08:14

you're like I don't even know where to start for

08:16

architecture patterns. That is totally okay.

08:19

You can leave some of these sections out if you

08:21

want, but and what I would really encourage you to

08:24

do is you can research things with the AI coding

08:27

assistant, like ask it. What are some ideas you have

08:29

for architecture patterns for this new feature or this new

08:32

project? Have it give you some options with pros and

08:34

cons so that you can really be a part of

08:36

the conversation with it making those decisions. I would highly

08:39

encourage you to spend the time doing that in the

08:43

layer 1 planning. That's where most of your time really

08:45

is going to be dedicated. Just figuring out these things

08:48

with the AI coding assistant. And so for our cloud

08:51

dot m d specifically, I have that also in this

08:54

folder here. So you can just read through some of

08:56

this if you want or ask an l m to

08:58

summarize it. We're gonna dive into this a lot more

09:00

in the next module, but all of the different sections

09:02

we have here with a lot of detail

09:05

revolving around our existing code base for the Obsidian agent.

09:08

Because right now, we are gonna be focused on layer

09:11

2 planning and building a feature on top of where

09:14

we've already done a lot of the project planning. So

09:16

I've got my global rules already created here. But just

09:18

to show you a very brief example of how you

09:21

could create these, I'll go back to my coding assistant

09:23

here and I'll just say,

09:25

explore my code base and

09:27

help me figure out the testing strategy,

09:31

the architecture,

09:33

the documentation

09:34

patterns,

09:35

the principles

09:36

I am following or this code base is following. Right?

09:39

Like, each of those different sections of the rules that

09:42

you want to create, you just have a conversation with

09:44

the AI coding assistant. And this is for an existing

09:47

code base. For a new code base, you could give

09:49

it your idea and say, like, search the web for

09:51

best architecture or documentation patterns. Right? Like it can do

09:54

research to help you with that as well. So I'll

09:56

send this in. It's not going to write any code

09:59

at this point, but that's good. It's just a conversation.

10:01

And then I can ask it to turn that into

10:04

my global rules. So there we go. Cloud Code spent

10:07

3 minutes analyzing

10:09

my entire code base, or if this was a new

10:11

project, could be doing research online, whatever that might be

10:13

to figure out things like the architecture and testing strategy.

10:17

And if you're serious about creating a really well defined

10:19

rules, turn this into a longer conversation. Make sure that

10:22

you and the AI coding assistant are really on the

10:25

same page with everything here. And then basically what you

10:27

can do is say go and turn this into a

10:31

claud dot m d or if you're using codex or

10:33

something like cursor, agents dot m d, like whatever the

10:36

name is for the rules for your AI coding assistant.

10:39

And 1 last super tiny tip before we go on

10:41

to layer 2 of planning is a lot of AI

10:44

coding assistants like Cloud Code have a special command to

10:47

help you set up your rules. And so slash init

10:50

is going to basically be a more structured way of

10:52

going through what I just showed you, where it will

10:55

walk you through,

10:56

analyzing the code base and defining things like architecture based

11:00

on that. I just get a little bit uncomfortable because

11:03

there's a workflow defined behind the scenes that I can't

11:06

really customize, but this is kind of an out of

11:08

the box way to help you create your global rules

11:10

for an existing project. It's pretty neat. So with that,

11:14

let's now move on to layer 2, our task planning.

11:18

So we have our global rule set up and we'll

11:20

talk more about creating full systems around rules and commands

11:23

in the next few modules. But right now, we're gonna

11:25

dive right into Vibe planning

11:27

to build some new capabilities into our Obsidian agent. And

11:31

so I'll just open up the agent again right here.

11:34

So this is pretty cool. I was able to read

11:36

through our files, search, edit files as well. 1 thing

11:40

that this agent isn't able to do yet though is

11:43

help us organize our folders. So it can organize

11:47

files right now, but it's not able to, for example,

11:50

create a folder or rename a folder. It can only

11:53

do those operations on files. And so for a very

11:56

simple use case to demonstrate the PIV loop for you

11:59

here,

12:00

for our layer 2, we're gonna be Vybe planning, specifically

12:03

creating tools for our agent to manage our folders. And

12:06

so you don't have to watch me type everything out,

12:08

I'm gonna be using a speech to text tool called

12:11

Aquavoice. This is just 10 dollars a month. I would

12:13

highly recommend it. There are some free and open source

12:16

options if you want as well. I would highly recommend

12:19

checking out Epicenter Whispering if you want something that is

12:22

free and open source. Open whisper is another option. So

12:25

I'll link to all 3 of these below, but I

12:27

just wanna call this out because this is how I

12:29

am working with AI coding assistants every single day. I'm

12:33

very rarely

12:34

actually typing something out to my Claude code. I'm always

12:38

using Aquavoice. You can see right here that I have

12:41

spoken over 300000

12:43

words

12:44

with Aquavoice. They've saved me 4 days of typing. I

12:47

get 236

12:49

words per minute when I am using Aquavoice, and I

12:52

can definitely not type that fast. And so going back

12:56

into cloud code here, let's do some vibe planning, and

12:59

I'm gonna be speaking into cloud code, so I'm not

13:02

gonna be typing anything.

13:03

So the very first thing I always do when I'm

13:06

starting a new conversation with a coding assistant working on

13:09

an existing code base is I like to prime it.

13:13

And we're gonna be talking about priming a lot in

13:16

module 4.

13:17

But it's the general idea that we want to catch

13:21

our AI coding assistant up to speed on what our

13:23

current code base looks like before we ever even start

13:26

talking about building a new feature.

13:29

And so I want to just generally describe the key

13:31

files I want it to read

13:33

to get that into its context. And so I'm gonna

13:36

go into Aquavoice here, and I'm gonna say,

13:39

go ahead and read the readme dot m d. And

13:41

then also, I want you to read the agent dot

13:44

py in the agent folder. So that way you have

13:46

a clear understanding of the AI agent

13:49

and this application as a whole. And then also read

13:52

the core files that we have in the shared folder.

13:56

Boom. There we go. Sending this in and look at

13:58

how fast that was. And no matter the tool you're

14:01

using like OpenWhisper or something else, it'll probably be pretty

14:03

fast and about as accurate. So, yeah, I really love

14:06

using speech to text tools. So there we go. I'm

14:08

gonna send this in. Now our coding assistant, after it

14:12

is done with this turn, is going to have a

14:14

much better understanding of our code. So we can go

14:16

into our feature planning.

14:18

So there we go. It read through the core files

14:20

in our repository, and now it has a very good

14:22

idea of our code base. And it's okay if you

14:25

don't know what the core files are exactly. You can

14:28

make this a much more vague prompt and just say,

14:30

like, analyze the code base and the core files of

14:33

the implementation. It'll still do a pretty good job. But

14:35

if you can be more specific,

14:37

that's always better. Again, removing assumptions from our AI coding

14:41

assistant. And a quick hint here, our priming is the

14:45

first thing that we're gonna be turning into a reusable

14:48

prompt in a couple of modules from now. So perfect.

14:51

We're ready to go into some feature planning here. So

14:53

I'll go back into Aquavoice and I'll say,

14:56

alright. Now that you understand the code base, I want

14:58

to do some feature planning with you. I wanna add

15:01

some new capabilities to the agent similar to the note

15:05

manager tools, but this time for folders. I wanna be

15:08

able to operate on folders, renaming them, deleting them, moving

15:11

them, explore the options for how we can build this,

15:15

and then report back to me a few different options

15:18

in the format option colon,

15:21

description of option colon,

15:23

trade offs colon, and then effort colon. Alright. Boom. Send

15:26

this in. Looking really good. Sometimes it's a little awkward

15:29

when you say colon or dashes and things like that,

15:32

but I find that that works really well working with

15:34

coding assistance, even like speaking out the special characters. So

15:37

I'll send this in. And again, no structure to the

15:41

vibe planning here. I'm just giving you an example of

15:43

what it looks like to explore. The main thing that

15:45

I'm showing you here is that's really helpful

15:48

when we don't really know how to build something at

15:50

first to just have the AI coding assistant think of

15:53

options for us. And then in the end, we're still

15:55

in the driver's seat because we're picking the option we

15:58

want to go with, but we're giving the AI coding

16:00

assistant freedom to really explore and think through different things.

16:04

So here we go. We got quite a few options

16:06

from our coding assistant. Maybe more than we need, but

16:08

that's totally okay. I guess that wasn't very specific there.

16:11

So option 1, creating a separate folder to manage all

16:14

the tools for managing folders and that's following the existing

16:18

pattern that we have for our other tools. So it's

16:20

good that it recognized that based on our priming. Couple

16:23

of other options, extend the vault organizer folder operations,

16:27

hybrid,

16:28

okay, 2 tier approach. So we have pretty much every

16:31

option I can possibly think of, it has covered here.

16:34

And it even gives me a recommendation. Option 1, a

16:37

standalone tool, which I looked at this a bit off

16:39

camera and I definitely agree here. And so I'm going

16:42

to say, okay. Yeah. I'm definitely leaning towards option number

16:45

1 as well. Now I want you to help me

16:47

think through what this implementation would look like exactly. I

16:51

wanna make sure this supports Windows, Mac, and Linux. What

16:54

else do we need to think about for this implementation?

16:56

Just help me do some more planning on this.

16:59

Boom. Send that in. Alright. There we go. So, yeah,

17:02

kind of a couple of different random things that I

17:05

I gave it here, but I'm doing that on purpose

17:07

to show you that it can just be very, very

17:09

free flowing. As you're working with the coding assistant, just

17:11

just whatever the heck comes to mind, any questions that

17:14

you have, just throw it in there. At this point,

17:16

we don't need structure.

17:18

Okay. So I'm not gonna cover the full vibe planning

17:21

phase because I think you generally get the idea of

17:23

some of the things you're looking for. 1 other thing

17:25

to call out that's really neat is when it asks

17:27

me questions

17:29

about key decisions to make. I really like when my

17:31

AI coding assistant does this and I'll even ask for

17:34

it to do this sometimes. So again, you're really just

17:37

working to get on the same page with your coding

17:39

assistant for what needs to be implemented.

17:42

And maybe this is all you're gonna do for your

17:44

vibe planning. Just a few different prompts.

17:47

Maybe it's gonna be 8 prompts. Maybe it's gonna take

17:49

you an hour and a half because you really wanna

17:51

make sure that you have everything perfect. It's totally up

17:54

to you. Just work until you get to the point

17:57

where you feel like you understand what's gonna be implemented

18:00

and your coding assistant also understands.

18:03

Now at this point, this is when we get into

18:05

leveraging this conversation to create our structured plan. And so

18:09

I'm gonna paste in the prompt here. I know it's

18:11

pretty big, but don't worry. It's not an expectation

18:15

that when you ask for a structured plan, it's gonna

18:17

look like this. At least not yet because another hint

18:21

here, this is something else that we can turn into

18:24

a reusable prompt going forward because basically we're outlining

18:28

the structure

18:29

that we want for our plan.

18:32

All the different sections that we wanted to create based

18:35

on the conversation we just had during vibe planning. So

18:37

going back to our diagram here, we just finished this.

18:41

Now we want to create a plan that has the

18:44

4 pillars of context engineering. So we're leveraging

18:47

the Vybe planning stage as our memory. We wanna talk

18:50

about the documentation

18:51

reference or reg, our task list. I mean, really the

18:55

way that we're creating this, all of this is prompt

18:57

engineering. So we're applying everything around context engineering to create

19:01

this structured plan. And so the prompt that I just

19:03

pasted into Claude Code

19:05

is outlining all of these different sections and a brief

19:08

description so the coding assistant understands what it's supposed to

19:11

put there based on our conversation.

19:14

So I hope that makes sense. We are creating

19:16

the detailed plan of attack here. So going back to

19:19

cloud code,

19:20

for example, I have my validation strategy and testing strategy.

19:24

So that's gonna get into in a couple of videos

19:26

when we cover validation more, but I'm outlining that right

19:29

away in our plan. We have the implementation

19:32

plan, so this is gonna be our task list. We

19:34

have the user story, which is going to define our

19:37

goal and probably our success criteria as well. So you

19:41

can see how all those things that I covered in

19:43

the Excalidraw diagram are relating directly to what we're asking

19:46

for, when we are creating our structure plan. And the

19:49

output here is going to be a markdown document called

19:52

coding dash prompt. So this is what we're gonna give

19:56

as context for implementation in the next video. And so

19:58

I'm gonna go ahead and send this off and you

20:01

can create this however you want. Just this is where

20:04

you get structured. That's the 1 goal that you have

20:06

here. So I'll come back once it's created our markdown

20:10

document. And boom, there we go. We now have our

20:13

structure plan in a document ready for implementation.

20:16

However,

20:17

please, before you go on to implementation,

20:20

read this document and make sure that the coding assistant

20:24

actually understands the task at hand here. And sometimes these

20:28

documents can be quite long depending

20:30

on how many different sections you wanna have for your

20:33

structured prompts, and that is totally up to you. Again,

20:36

very flexible here.

20:38

So I would recommend reading through each of these, making

20:41

sure that everything makes sense. Feature description, problem statement. Let

20:44

me go into the the better view here. We've got

20:46

our user story that has the success criteria. This is

20:50

looking really, really good. So we've selected option number 1

20:53

of the standalone tool. So it's pulling in our previous

20:56

conversation to help with the context here.

20:58

Key decisions that we made throughout our conversation,

21:01

the relevant files for our integration points, super important for

21:05

working with existing code bases. And if it's a brand

21:07

new project instead of relevant code base files, you're probably

21:10

gonna have documentation and reference online, for example, for your

21:13

libraries or architecture, things like that. Implementation plans. So we

21:17

have our task list. This is beautiful.

21:20

I'm not gonna go through all this in a ton

21:22

of detail here because I'll leave that up to you.

21:24

Probably not super interesting for you right now. But if

21:26

you have any problem with this, you can either edit

21:29

it yourself

21:30

or what I'd recommend doing is going in the coding

21:32

assistant. Just saying something like, the implementation plan is

21:36

too long here. I want you to make it more

21:38

concise. You're over engineering. Right? Like, that's just 1 example

21:41

that you can do to send this in, and it'll

21:43

go and correct a part of the plan. Which by

21:45

the way, Claude, especially, really any large language model, loves

21:49

to talk a lot. They like to write more code

21:51

than you

21:52

need, and so you'll find yourself doing this a lot

21:55

where you'll ask it not to over engineer and to

21:57

simplify something. So just another golden nugget for you is

22:00

that's the main thing that I look out for when

22:02

I read through these plans and really review any code,

22:05

is to make sure that what is created

22:08

is not more than it needs to be. Because coding

22:10

assistants love to

22:12

handle exceptions way too verbosely, and they like to add

22:15

in backwards compatibility. All these things that grind my gears

22:18

every time I see them. So just make sure that

22:20

you look out for those kind of things. But just

22:22

at a high level, making sure the plan fits with

22:25

the vision that you have for this implementation.

22:28

So there you go. That is everything that I have

22:30

for you for planning. Our first iteration of the PIV

22:33

loop, We are now going on to implementation.

22:36

And just like with the VIE planning stage, spend as

22:39

much time as you need with creating your structured plan

22:43

until you're very confident in what the coding assistant has

22:45

created for each of the sections that you have defined.

22:48

And you can, again, just take inspiration from these, but

22:51

really customize it to what you are working on. Once

22:54

you're confident in your plan of attack for the AI

22:57

coding assistant,

22:59

that is when you move on to implementation. And so

23:01

in the very next video, I'll show you what it

23:03

looks like to prompt for the execution of our plan.

23:06

We're gonna do that in a brand new conversation with

23:09

our coding assistant, and then I'll show you what it

23:11

looks like to trust but verify and just generally how

23:14

I watch out for these things. And overall, this video

23:17

is gonna be a lot shorter than this current 1

23:20

because we already have all the structure in place now.

23:23

And so we're just gonna let it rip and then

23:25

we'll go on to validation in 2 videos from now.

23:28

So I hope that all sounds good to you and

23:30

with that, I will see you in the next video

23:32

for implementation.