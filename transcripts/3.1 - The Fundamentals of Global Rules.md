---
course: Dynamous Agentic Coding
module: 3
lesson: "3.1"
title: "The Fundamentals of Global Rules"
type: lecture
status: raw
date_added: 2026-02-18
date_modified: 2026-02-18
tags:
  - dynamous
  - agentic-coding
  - module-3-global-rules
  - global-rules
  - claude-md
key_concepts: []
prerequisites: ["2.4"]
related_lessons: ["3.2", "3.3", "3.4"]
---


Welcome to module 3 of the DynaVis agentic coding course.

00:04

This is all about global rules, which really do deserve

00:08

their own dedicated module because they're so important when working

00:11

with AI coding assistance, and global rules are also part

00:14

of the foundation of any system that you will create.

00:18

And so over the next few videos, we'll be using

00:20

this Excalidraw diagram to cover the what and the why

00:23

of global rules. And then for the how, we have

00:26

our GitHub repository, the agent decoding course GitHub repo, where

00:30

I'll show you some examples of global rules and my

00:32

general recommendations for some of these sections to have in

00:35

each of them. And, of course, the golden rule is

00:38

to always customize a lot of my recommendations

00:41

to your specific use cases for rules, for workflows,

00:44

for everything.

00:46

And the pace that I have here, I think is

00:48

gonna be good no matter if you're a beginner or

00:50

if you've been working with global rules for a while.

00:52

Because as I introduce global rules, I'm gonna be making

00:55

recommendations

00:56

for how to organize things and what fits into rules

00:59

at the same time. So at the highest level possible,

01:03

Global Rules are the core of layer 1 planning, and

01:06

we're really gonna get into layer 1 planning in this

01:08

module.

01:09

And specifically, they're the stable foundation that is auto loaded

01:13

into every AI session. It's the core principles

01:16

we always want our AI coding assistant to follow. If

01:19

you're familiar with building AI agents,

01:21

global rules is very similar to a system prompt.

01:26

And speaking of layer 1, going back to the PIV

01:29

loop diagram that we talked about in the last module,

01:32

we covered the 2 different layers of planning. We have

01:35

both project planning

01:37

and task planning.

01:39

This module is going to be dedicated to the first

01:42

layer, and I promised you in the last module that

01:44

when we focused on task planning, we would get to

01:47

the project planning in a lot more detail. That's what

01:50

we're gonna start to dive into right now. Because your

01:53

layer 1, this is what is done once and updated

01:55

rarely. It's the

01:57

core principles and architecture and tech stack that you want

02:00

to communicate to your AI coding assistant, the stable resources,

02:04

which your global rules is the biggest part of your

02:08

stable resources. That's why it gets an entire module in

02:12

this course.

02:13

So going back here, I want to start by talking

02:15

about

02:16

how we can create our global rules, then we'll get

02:20

into the different sections that I recommend having in them.

02:23

So no matter your AI coding assistant, it will have

02:26

the concept of global rules. It might be called something

02:29

different, like in Cura, it's called your steering document, for

02:31

example,

02:32

but it's the same idea. It's your core principles

02:36

that you always want to have in the context window

02:38

for your coding assistant

02:40

guiding it on the highest level kind of golden rules

02:43

and standards for your code base. And so in Cloud

02:46

Code, it's a markdown document called Cloud. Md.

02:49

In the codex, Cursor, Gemini CLI, quite a few different

02:53

ones, it's called your agents dot MD. And then if

02:56

you've used Cursor or Windsurf way back in the day,

02:58

they used to have this dot notation or it'd be

03:00

like dot cursor rules or dot windsurf rules.

03:03

If you've worked with AI coding assistance much in the

03:05

past, you've definitely seen this because global rules are that

03:09

critical. And the reason why there's so many listed here

03:11

for agents dot MD is it's starting to become a

03:14

universal standard. So it's similar to how in a GitHub

03:18

repository, we always have the readme file. It's sort of

03:21

like the 1 file for the human

03:23

to quickly understand what a project is all about.

03:27

And so we have readme for the human, and now

03:29

we're starting to have agents dot MD for AI agents.

03:32

So just like a read me is for us to

03:34

understand a project at a high level, agents dot m

03:37

d or our global rules is a way for the

03:39

coding assistant to understand the project at a high level,

03:42

but probably more directed to how we want it to

03:44

make changes into our code base, if that makes sense.

03:47

Right? So at some point and we haven't seen this

03:49

yet because agents dot MD is still becoming the standard,

03:53

but I assume what we'll see really soon here is

03:55

that most GitHub repositories will have the readme and then

03:58

also an agents dot m d. So it'd be like

04:01

readme right here and then an agents tab. So both

04:03

human and AI have their respective files to understand

04:07

a project. Okay. So the next question is where do

04:10

we put our global rules in our code base?

04:13

And my general recommendation,

04:15

especially to keep it simple at first, is to have

04:17

a single global rule file, like a single agents dot

04:21

MD or a single cloud dot MD at the root

04:23

of your repository, generally right next to your read me.

04:27

Now it can get a bit more nuanced than that,

04:30

but for most of my projects, I find that to

04:32

be sufficient. And so I'll link to these 2 files

04:35

below in the description as well. But this guide for

04:39

using Cloud Code, they talk about your global rules for

04:41

a little bit. There are quite a few different places

04:44

you can put global rules, and you can incorporate

04:47

multiple cloud dot MDs in a single project. I generally

04:50

find this to be over engineering, but I just wanna

04:52

mention this really quickly. So, of course, first bullet point,

04:55

the root of your repo like I just said. And

04:58

so alongside your read me and, you know, your other

05:00

core files like your package dot JSON, your requirements dot

05:03

TX. You can also put it in any parent directory

05:05

and so Claude is going to actually go up and

05:08

find that and load it in. You can have it

05:10

in children directory. So when Claude is working on files

05:13

in that directory, it'll automatically include that context as well

05:16

because you might have principles

05:18

that are specific to a certain part of the code

05:20

base you only want to pull in when you're working

05:23

on that part of the code base. And then you

05:25

also have your home folder. And so this is where

05:28

you can put global rules that are going to open

05:30

up in all of your AI coding assistant sessions, not

05:34

just the 1 in that specific code base. Right? Like,

05:37

when we have a global rule in the root of

05:39

our repo, it's only gonna use that context when we

05:42

start our coding assistant in that folder. But this is

05:45

what's going to apply at a global level. And it's

05:48

kinda similar for agents dot MD. There's a little bit

05:51

less options to make it simple, but basically you have

05:54

the agents dot MD at the root of your repository,

05:57

and then you can also have nested agents dot MDs

06:00

in different subfolders

06:01

like you can do with claw dot MDs as well.

06:05

And so it does change a little bit between your

06:07

coding assistants, but the 1 thing that is always universal

06:11

that I'd recommend is having a single global rule file

06:14

at the root of your repository, at least starting there.

06:17

And the core golden nugget that I want to give

06:20

you right here is that your global rules is your

06:22

day 1 onboarding for your coding assistant. It's everything it

06:26

needs to know on the first day, and I'll kinda

06:28

talk about how we can expand that analogy later as

06:31

well. But first, I wanna talk about what we should

06:34

actually be including in our global rules. So the main

06:38

mental model to have when you're thinking about what to

06:40

put in your global rules is just think about what

06:42

you would describe to another person when they're looking at

06:45

your code base for the first time and you want

06:47

to explain how your project is structured. You're going to

06:50

talk about the tech stack and architecture.

06:52

If you want them to make changes on your code

06:54

base, you want them to follow your code styles and

06:56

patterns like your naming conventions with variables for example.

07:00

You want them to test in the same way that

07:02

you're testing.

07:04

And also, maybe you've worked with other people on your

07:07

code base before, and you know the kinds of misconceptions

07:10

they might have that you wanna clear up, like maybe

07:12

around how you handle environment variables, for example.

07:15

These are all of the core things that I would

07:17

include in global rules. And of course, customize this to

07:20

your code base specifically. There might be a really important

07:24

concept that you wanna have a section for, that you

07:27

wanna add on to this for your code base, do

07:29

that. I encourage you to think about how you can

07:32

apply a kind of more general recommendation

07:35

like what I have for you here to something more

07:38

specific to your code base to tweak and expand what

07:40

I've got here. And to give you an example of

07:43

what global rules look like, I've got a couple in

07:46

the repository here. So I've got 2 versions for you

07:49

because there are 2 camps, different ways that people set

07:52

up their global rules. It's all up to preference. I

07:55

wanna cover both of them. Starting with the simpler 1,

07:58

version 1. This is where we have all of our

08:01

global rules in a single file. So I'll go into

08:03

the preview mode here. Let's take a look at this.

08:06

And this is all based on that diagram that I

08:08

showed you earlier. We have the same principles.

08:10

So we got our core principles,

08:12

highest level things that we want to follow. We have

08:15

the tech stack so the agent quickly knows the different

08:18

technologies and libraries that we're working with. Our general architecture

08:22

which also helps it navigate through our code base. We

08:25

have the code style, like, for Python and our back

08:27

end. This is our naming convention for things like classes

08:31

and functions.

08:32

Same kind of thing for our front end. This is

08:34

how we handle logging. This is how we handle testing.

08:37

Right? Like, I don't have to explain this section by

08:40

section, but you get the idea here, like, including different

08:42

commands that it can run to work with our project

08:44

and run tests for our project.

08:46

This is everything that we want to include no matter

08:49

what we're doing in our code base. We're fixing a

08:51

bug, we're adding a new feature, we're starting something from

08:54

scratch. Like, these 10 sections,

08:56

we wanna have loaded into our AI coding assistant

08:59

all of the time. Now there is 1 other way

09:02

you can set up your global rules to make things

09:05

more modular if you want to work with different files.

09:08

Because what you can do, and this is what I

09:10

have in the version 2 of the global rules, is

09:13

you can mention or reference

09:16

other files. And when you give a full path to

09:19

a file and you put the at in front of

09:21

it in global rules, what that means is when you

09:24

start the AI coding assistant session and it loads in

09:27

the global rules, it is automatically going to replace this

09:30

reference with all the contents of that file. And so

09:33

it definitely comes down to preference if you wanna do

09:35

it this way or the way that I just showed

09:37

you, but these 2 global rules are exactly the same

09:40

because all the different sections that I'm loading in with

09:43

with the at reference, this is all the same content,

09:47

but it just makes things more modular

09:49

at the cost of having to manage different files. So

09:52

it's a trade off. It really is up to you

09:54

if you want to have more files but then things

09:57

are more modular or if you just wanna keep things

09:59

as simple as possible.

10:01

And so, like, generally, I actually recommend doing it the

10:03

first way where everything's just in a single file. I

10:05

just like maintaining a single file, and global rules are

10:08

pretty short overall. But then, for example, I actually had

10:12

the pleasure of talking to an Amazon engineer, and I

10:15

got to see from him how his team manages their

10:18

global rules. And they actually do it this way because

10:20

they have a ton of these universal markdown documents for

10:23

principles that they've been following even before using AI coding

10:27

assistance. And so they just have this in a repository

10:29

where all their team members take it, put it in

10:32

a folder, and then they have their global rule set

10:33

up to reference each of them. And it's also nice

10:36

because then sometimes I don't have a specific example in

10:39

mind, but sometimes you might want to take out a

10:42

certain section for a feature development that you're doing. So

10:44

you can just do that really easily,

10:46

versus when you have everything together here, it's a bit

10:48

harder to, like, find the start and end of each

10:51

section to do the same thing. Right? So just trying

10:53

to give a couple examples to help you think through

10:55

which 1 you'd want yourself.

10:57

If you want the simplest, I would go with version

10:59

number 1. That's why I'm calling it version number 1.

11:02

But, yeah, totally up to you. That's just 1 of

11:04

the core things I wanted to cover with global rules.

11:07

Also, the anthropic guide to cloud code that I showed

11:09

earlier has their own recommendation of things to put in

11:12

your global rules. And, of course, this is for anything,

11:14

not just cloud code as well. And so, yeah, everything

11:17

that you see in this list is going to be

11:20

very similar to what I just described to you. Right?

11:22

Because it's always just the high level principles. So they

11:25

say common bash commands. We saw some command references and

11:28

the global rules we just looked at, core files and

11:30

utility functions, code style guidelines, testing instructions.

11:34

I didn't say everything explicitly here, but you get the

11:37

idea. Right? And you can definitely take inspiration from my

11:41

list and this list to think for yourself those high

11:43

level principles

11:44

that you always want to have in your global rules.

11:48

And the other thing that I can recommend for you,

11:50

and this is honestly even more important, is what not

11:53

to include in your global rules. So for example, there

11:57

is absolutely

11:58

no reason to include universal knowledge in your global rules

12:03

because large language models are already pretty intelligent. So anything

12:06

that's gonna seriously bloat the rules, just avoid it. Right?

12:09

Like, you want to be as concise with your global

12:12

rules as you possibly can because that's the context that

12:15

is always going to be sitting there in the conversation

12:18

history with your coding assistant.

12:20

Also, anything

12:21

around workflows or commands. So if there's any sort of

12:24

process

12:25

that you want to describe to an AI coding assistant,

12:28

the global rules is not the place for that. And

12:32

that's what we're gonna be talking about a lot in

12:33

the next module. When we get into commands, reusable prompts,

12:36

that's where we'll be mapping out processes

12:39

for AI coding assistance. So think about it this way,

12:43

global rules is for principles.

12:45

Your commands that we're getting into in the next module

12:48

is for your workflows. Right? So keep that in mind.

12:51

And then the last thing I'll say is anything that's

12:53

very specific to your tasks. And the reason for that

12:57

is global rules should apply to any task that you

13:01

are implementing in your code base because they're always going

13:04

to be there. So when we think about the different

13:06

layers of planning

13:08

that I was talking about with the PIV loop let

13:10

me go back here. Layer 1 planning is your entire

13:14

code based context. The global rules fit into this. And

13:17

then layer 2 planning is the task specific stuff. So

13:21

here's the thing.

13:23

Layer 1 planning done once updated rarely. Layer 2 is

13:26

done for each task. This is going to change every

13:28

single time you're in a new conversation with your coding

13:31

assistant. And so the golden rule here is if anything

13:34

in your global rules changes a lot, it probably or

13:37

I should even say it certainly

13:40

does not belong in your global rules. Alright. Cool. Hope

13:43

that makes sense to you. The last thing that I

13:45

wanna talk about here is the why.

13:48

Why do we care about incorporating global rules at all

13:51

into our code base? I mean, all these high level

13:53

principles. Can't we just have a quick conversation with every

13:56

coding assistant session and have it discover these things? I

13:59

mean, there's nothing fancy here going on, which that's on

14:02

purpose by the way. But here's the thing. Global rules

14:06

are super important

14:07

because they help solve what I like to call the

14:10

context loading task.

14:12

Every session, think about this, the AI coding assistant starts

14:16

with 0 knowledge on your project. And that's a bummer

14:20

because there's a lot of work if we're starting from

14:22

0 to get it to the point where it understands

14:25

our code base so we can actually do the thing

14:27

we want to do, like build that next feature or

14:30

solve that bug. And so there's 2 approaches to catching

14:33

it up to speed on our project. Approach number 1

14:37

is manual context loading. So kind of like I was

14:39

saying in the example earlier, we start a session and

14:42

we have a quick conversation with the coding assistant so

14:45

it discovers things like our tech stack and architecture.

14:48

But we pay this tax every single session. Even if

14:51

you're pretty fast, it's gonna take you a few minutes.

14:53

And so you have to explain, do some work. Next

14:56

conversation, you have to explain it all again, and this

14:58

is going to take hours and hours over time.

15:02

Now the second approach with our global rules is we

15:05

are front loading the context. We pay the tax once,

15:08

and it might cost a bit of time upfront.

15:11

Like, instead of just going into a conversation right away

15:13

and spending 5 minutes, we have to carefully curate our

15:17

global rules and craft that for, you know, 30 minutes,

15:19

an hour, maybe even more. So it's gonna take some

15:21

time upfront,

15:22

but now our system can automatically load this every single

15:26

time so we don't have to re prompt. And so

15:29

auto load work, next session auto load and work. And

15:32

man, does this save so much time. Over the course

15:36

of working on our code base for feature after feature

15:39

over weeks and months and even years. Right? So it's

15:42

definitely worth putting in the time upfront. I mean, that's

15:44

really all of planning both with layer 1 and layer

15:48

2. It's all about putting in that time upfront to

15:51

save time later, going into your current implementation

15:55

and beyond.

15:56

And so the last thing that I'll say here is

15:58

that front loading your context.

16:01

It's not just global rules.

16:03

That's what we're gonna talk about in the second video

16:06

with the 2 different loading strategies

16:09

for layer 1 planning. And so I'll leave you with

16:12

this right now, and then I'll elaborate on it a

16:14

lot more in the next video. Your global rules, like

16:17

I said earlier, is kind of like your day 1

16:19

employee training. It's the high level stuff that you need

16:22

to learn right away. And then dynamic

16:25

context, this is the other part of front loading. That's

16:29

kind of like your department training. So when you want

16:32

to get a little bit more specialized working with different

16:34

task types,

16:36

that is your dynamic context. All of this together makes

16:39

up your layer 1 planning. And then when you get

16:41

very specific to a single task, that is your layer

16:44

2 planning. That's like working on this week's assignment. Right?

16:47

So you're an employee, you get onboarded, then you have

16:50

your department training for a week, and then you get

16:52

your first assignment, and now things get very specific. So

16:55

I hope that makes sense. A lot more on this

16:57

in the next video.