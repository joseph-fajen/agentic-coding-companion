---
course: Dynamous Agentic Coding
module: 3
lesson: "3.2"
title: "The Two Strategies for Context Loading"
type: lecture
status: raw
date_added: 2026-02-18
date_modified: 2026-02-18
tags:
  - dynamous
  - agentic-coding
  - module-3-global-rules
  - context-loading
  - on-demand-context
key_concepts: []
prerequisites: ["3.1"]
related_lessons: ["3.3", "4.1"]
---


Alright. So in the last video, we talked about the

00:02

what and the why of global rules and what goes

00:04

into them generally. But I left you on a cliffhanger

00:08

because I said that layer 1 planning

00:10

or the front loading of context is more than just

00:14

global rules. And so now I wanna cover that with

00:17

you because this is where we'll dive into

00:20

the complete picture of layer 1 planning because it is

00:24

our global rules, but then also some other things that

00:27

make up our stable resources. That's what we're looking at

00:30

right here. Alright. So the primary mental model that I

00:33

have for you that very much applies to global rules

00:36

is that layer 1 planning has 2 loading strategies.

00:40

So okay. We already talked about task planning quite a

00:43

bit in the last module. I will focus just on

00:46

layer 1 planning.

00:47

But even layer 1 planning can be split into 2

00:51

parts. Think about it this way. You have your automatic

00:55

context that you always wanna be brought into your AI

00:57

coding assistant. That is your rules. But also, you're going

01:01

to have some other

01:03

references and guides that you might wanna have as context

01:06

in layer 1

01:08

that's not for an individual

01:10

task. So it's not specific enough to be layer 2,

01:14

but also it's only for certain task types. And so

01:17

it's kind of this in between. It's not something that

01:20

applies to everything no matter what we're coding, so it

01:23

doesn't go in global rules.

01:24

But also it's a higher level guide that's gonna apply

01:28

to many different tasks that we're gonna be building throughout

01:31

our code base. And so for these specific task types,

01:35

we have these reference documents that are gonna be used

01:37

by our system.

01:39

And I'll give you an example of this right here.

01:41

So this is like a super, super basic example

01:44

of the global rules for our Obsidian agent we're building

01:47

in this course. We have our tech stack, our architecture,

01:51

testing requirements, logging requirements, like these are the things that

01:54

our coding assistant needs to pay attention to no matter

01:57

what it's doing. If it's building a new tool, if

01:59

it's doing something with our API, if it's fixing a

02:02

bug, like these are our golden principles.

02:05

But then also,

02:07

here's an example of an as needed document. We have

02:10

this guide here on how to build tools into our

02:13

AI agent

02:14

just like we did in the last module.

02:17

And so building tools

02:19

is the task type. You can see here that when

02:23

we are, you know, doing something with our API or

02:25

fixing a bug, we don't really care about this guide

02:28

on building tools. But also, we're gonna be building tools

02:31

into our agent quite a bit throughout this course, and

02:33

so we don't want this set of instructions in our

02:35

layer 2 planning because we actually want to reuse this

02:38

quite a bit. Right? Like, this is a part of

02:40

our project planning because

02:42

building tools into our agent is gonna be something we're

02:44

gonna do many, many times as a core part of

02:47

our project. I hope that makes sense how this fits

02:50

in between the automatic stuff we always want in our

02:52

global rules and the very task specific stuff. And so

02:56

I just got a couple of examples here

02:58

of how we are just, like, guiding our coding assistant

03:02

on creating tools. So it's principles

03:04

just like our global rules,

03:06

but it's for a specific task type.

03:09

And since it is not included in our global rules,

03:12

that means it's not loaded automatically.

03:14

And so we need to tell our AI coding assistant

03:16

to reference this as needed document

03:19

in some way.

03:20

Typically, you're going to do that through commands, and that's

03:24

what we're gonna dive into in the next module.

03:27

But for now, I wanna give you a super concrete

03:30

example of how we can take our layer 1,

03:33

and then we can split it into the 2 different

03:36

loading strategies. And that'll also be your exercise for this

03:39

module is analyzing

03:41

global rules and figuring out what parts of it don't

03:44

really belong here because it's for a specific task type

03:47

that we don't always want to reference. Alright. So back

03:50

over to our repo because I got a folder dedicated

03:53

to this video on the 2 loading strategies for layer

03:55

1 planning. I wanna give you a really solid example

03:59

of global rules and then talk about how we incorporate

04:02

the other part of layer 1 planning. These reference documents

04:06

that I have for specific task types. And so the

04:09

global rules right here is actually for the application that

04:13

you worked on top of in exercises 1 and

04:15

2. It's our product catalog e commerce app. And I

04:18

have the exact same sections here as I had in

04:21

the global rules from the last video. So I'm keeping

04:23

things super consistent like core principles, tech stack, architecture, code

04:28

style. You can read through all this if you're curious

04:30

and you just wanna take some more inspiration for the

04:32

kinds of things I put in my global rules. But

04:34

again, it is entirely up to you what you include.

04:38

Just use everything that I have here as suggestions and

04:40

inspiration.

04:42

And 1 thing, I'm gonna scroll all the way to

04:44

the bottom here. 1 thing that's very new in these

04:47

global rules is I have this section,

04:50

task specific reference guides. Take a look at this. I

04:54

call out the task type, like the other part of

04:57

our layer 1 planning in our global rules.

05:00

That is how we connect our automatic context with our

05:04

on demand context in layer 1. And so I'm not

05:07

including this in my global rules by default, but I'm

05:10

basically telling my coding assistant when you're working on this

05:13

type of app, like a when you're working on building

05:15

the rest API endpoints, or you're working on creating a

05:18

React component,

05:19

that's when you go and read the reference document,

05:23

the task type document, and you include that in your

05:26

context.

05:27

And so this is a lot better than just pasting

05:29

both of these things right into the global rules because

05:32

we don't always need this. Right? Like if I'm doing

05:34

something in the back end and I'm not even doing

05:36

anything with front end components, why would I read this

05:39

guide on building front end components? But if I am

05:42

building front end components, then I definitely wanna incorporate

05:46

the principles that we have here because this essentially is

05:49

tacked onto the global rules, but only when we are

05:52

working with this specific task type.

05:55

So I hope that makes sense. And so that is

05:57

1 way that we can bring on demand context into

06:01

our coding assistant. Basically, just in the global rules saying

06:04

we want to call upon

06:05

this extra guidance.

06:07

However,

06:08

I wouldn't actually recommend doing that in most situations.

06:12

I know. Maybe it's a shocker. I mean, I just

06:14

showed that in the global rules. Like, it's this new

06:16

thing for you to learn. But let me explain

06:18

what I mean. And so I'm gonna scroll down a

06:20

bit in this read me, which you can read through

06:22

this full thing if you want. But there are really

06:24

2 ways to load these reference guides, this other part

06:27

of layer 1. Method 1 is what I just showed

06:29

you. We can reference in the global rules. Right? Like,

06:32

when you want to build this kind of thing, then

06:34

you read this guide.

06:36

And the best part about this is it's very flexible.

06:39

We're allowing the AI coding assistant to decide when to

06:42

call upon this extra context,

06:45

and so we don't have to worry about that ourself.

06:48

But the problem is we're relying on the AI coding

06:51

assistant to figure out when to read this, and so

06:54

it might not in a situation where we actually want

06:56

it to. So the flexibility here kind of is the

06:59

pro and the con. And this is going to transition

07:02

very nicely into the next module when we talk about

07:05

commands and workflows because this is actually where I would

07:08

recommend

07:09

referencing

07:10

these task type guides.

07:12

And so again, we'll get into this a lot more

07:15

in the next module. But when we want to define

07:17

our

07:18

processes and workflows, that's when we use commands

07:22

versus our global rules and other layer 1 planning.

07:26

And so this is a super basic example of a

07:28

command that I have that we would call when we

07:31

want to build an API endpoint. And then in the

07:34

instructions here, like, as a part of our process,

07:36

we tell it to read the API guide markdown document.

07:40

Right? And so now instead of leaving it up to

07:43

the coding assistant to decide it needs to read this

07:45

because it's in the global rules, now we're telling it

07:48

explicitly. And you can see that we're even using the

07:50

at here, which in commands that's just like global rules

07:53

where when you use the at, it automatically loads all

07:56

the contents from that file. And so we are deterministically

07:59

injecting that into the context for the coding assistant because

08:03

we decide to use this command. And so we will

08:06

see examples of this in the next module. But the

08:09

the pro here is that it's guaranteed to be loaded

08:11

when we want it to be loaded.

08:13

And it just is not as convenient. Right? Like it's

08:16

not as flexible.

08:18

And so even though I would generally recommend the second

08:20

approach, it is up to you. Sometimes you have these

08:23

reference documents that you do want the coding assistant to

08:26

decide when it looks at, and so then it does

08:28

belong in the global rules. So I don't want to

08:31

deter you entirely

08:32

from this first approach, but I want you to really

08:35

grasp both of these approaches and prepare yourself

08:38

to be doing a lot of this in the next

08:41

module. We'll even have some exercises

08:43

for doing this kind of thing where we're including our

08:45

layer 1 planning as a part of the commands that

08:47

we build into our system.