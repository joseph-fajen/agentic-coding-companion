---
course: Dynamous Agentic Coding
module: 6
lesson: "6.1"
title: "The Execute Command"
type: lecture
status: raw
date_added: 2026-02-18
date_modified: 2026-02-18
tags:
  - dynamous
  - agentic-coding
  - module-6-execute
  - execute-command
  - implementation
key_concepts: []
prerequisites: ["5.7"]
related_lessons: ["6.2", "7.1"]
---

Welcome to module 6 of the DynaMed agentic coding course,

00:04

systems for implementation.

00:06

The first thing you probably noticed coming into this module

00:09

is that it is a lot shorter than the last

00:12

module on planning, and that, my friend, is very, very

00:16

intentional. I've been telling you as we've been going through

00:18

the PIV loop here that we should put a lot

00:20

of time upfront into planning. Because if we have a

00:23

structure plan going into implementation

00:26

that truly has all the context AI coding assistant needs

00:29

to knock out a feature, then the implementation phase itself

00:33

is really simple. We have most of the structure already

00:36

in place. Now literally all we have to do is

00:39

create a command in our system

00:41

to execute on that structured plan. That is it. And

00:45

so the proof is in the pudding. So much so

00:48

that the length of this module

00:50

directly reflects how the implementation is a lot shorter than

00:54

the planning. So things are pretty simple here. In this

00:57

video, I'll outline the execute command for you so we

01:00

can have the implementation part of our system ready. And

01:03

then we're gonna go through a couple of PIV loops

01:05

and things are really gonna come together here where we'll

01:07

have our plan feature. We'll do a little bit of

01:10

Vy planning, go into the structure plan, and execute it.

01:13

I'll talk a little bit about evolving our system based

01:15

on this process, and then we'll do it again. And

01:17

that is all we have for this module. So nice

01:20

and simple, really starting to bring things together here as

01:23

we are creating our system

01:25

that we're going to be validating in the next module

01:28

and then evolving and automating in the modules after that.

01:31

Also, as we are building our commands and really finalizing

01:34

our system in this module and the next, I'm curating

01:38

everything together into the dot agents folder that's at the

01:41

the top level of the main repository for this course.

01:44

And so really besides, I guess, the global rules, this

01:46

is all of the AI layer that we have in

01:48

the Obsidian AI agent repo. So I want this to

01:51

be a single place for you to go to if

01:53

you want to look at the PRD or take some

01:55

of these commands for yourself or use them to refine

01:58

your own system as inspiration. Do whatever you want with

02:00

this. I just wanna have this all in 1 place

02:02

for you. And then going into the next module of

02:04

validation,

02:05

I'll keep adding on to the commands that we have

02:07

here too. So I have the core PIV loop commands

02:09

like our priming and the planning feature that you just

02:12

built in the last exercise,

02:14

the execute 1 that we'll go over in a second

02:16

here.

02:17

I have, you know, the classic commit command that you

02:19

should be using pretty much after every time you create

02:21

a plan or implement a feature. And then also, I

02:24

made 1 to help create the PRDs. And so in

02:27

the last module, when I created the PRD,

02:29

as that last part of our layer 1 planning, I

02:31

did it manually. But you can template this out just

02:34

like structured plans and use a command in a very

02:36

similar way. So after you go through the Vibe planning

02:39

and defining the scope of your project, you can call

02:41

this create PRD

02:43

to build

02:44

what we built more manually. And so I just wanna

02:46

keep harping here that you want to automate and systematize

02:49

as much as you can. So I even added this

02:52

just to prove I feel like I probably should have

02:54

done that back in module 5, but there we go.

02:56

I have it for you now.

02:57

And then last but not least, we got that init

02:59

project 1. So that, on our Obsidian AI agent, we

03:02

can just ask it to follow the steps here to

03:05

start up the agent for us. So we don't even

03:06

have to go through that process. Or if we give

03:08

this to a new member of our team, for example,

03:11

they can just run this to get it up and

03:12

running very quickly. So that's everything that I've got for

03:15

the dot agents folder. I even have the commands folder

03:18

here because I don't wanna put it in a dot

03:19

cloud. I want this to be universal to your AI

03:22

coding assistant. So everything in the dot agents folder. And

03:25

so with that, now that we're talking about implementation

03:29

in this module, I wanna focus on the execute command

03:32

here. And so in this video, I'll go over why

03:35

I have things defined the way I do here, how

03:37

you can customize the execute command, then we'll see it

03:40

in action. So what is the purpose of the execute

03:43

command? Well, very simply put, this command is instructions for

03:47

how to handle our structure plan and implement the feature

03:51

through it. And there are 2 parts to the execute

03:54

command that I always include that I think are very

03:56

important.

03:57

First of all, we want to explain to the coding

04:00

assistant how thorough we want it to be. Like, make

04:03

sure you read through the entire plan carefully.

04:06

Make sure you execute all of the validation commands as

04:09

specified in the plan. And I know this looks a

04:12

little silly, but this does actually make a considerable difference

04:15

for some feature implementations. If you were to just give

04:19

the plan and ask it to build it without having

04:22

an execute command, sometimes it'll only read part of the

04:25

plan and try to, like, set up this phased approach

04:27

where it'll say, like, okay, I built this. Next up,

04:29

I'll do this when you give me permission. Right? Like,

04:31

it'll only do part of it or it'll only execute

04:34

some of the validation commands and then ask you to

04:37

do the rest. And so coding assistants have these little

04:40

quirks where sometimes they like to be lazy. And so

04:43

as a part of the execute command, we speak to

04:45

how thorough we want it to be. And then the

04:47

second really important part of execute commands is describing how

04:51

we want it to handle each task. And so in

04:54

a very basic sense, I'm just saying each task is

04:56

a step by step. So navigate to the task,

04:59

implement it, verify as you go. Make sure that you're

05:02

checking your work, not doing all the validation yet, but

05:05

doing simple import checks, checking the syntax of your code,

05:08

then moving on to the next task. And this is

05:11

also your place. If you have a specific workflow for

05:15

handling task by task execution, you can put it in

05:18

here. For example, maybe you are using a productivity app

05:21

like Notion or Jira, and after each task, you wanted

05:24

to go and update something. Or maybe you're using Archon,

05:27

which we'll talk about in the MCP server module, and

05:30

you wanted to manage tasks externally somewhere else. Right? Like,

05:33

your own process or maybe there's, like, a little bit

05:35

of research you wanted to do with a tool at

05:38

the start of every task. You inject that here. So

05:41

our structured plan

05:43

and our planning command, that outlines the tasks we want

05:46

to knock out. But how we do that? That is

05:49

where we specify that in the execute command. So those

05:51

are really the 2 things, how to handle tasks, how

05:54

to be thorough. It's pretty simple overall, which is also

05:56

why I don't have an exercise for you in this

05:59

module to create your execute command. But if you wanna

06:02

do a little bit of a bonus exercise, you can

06:04

definitely

06:05

take inspiration from something like this and then build your

06:07

own execute dot m d slash command. It's totally up

06:11

to you if you want or you can just go

06:12

ahead and take this and run with it. Because again,

06:14

this command and everything else I have in my AI

06:17

layer right now is right here in the dot agents

06:20

folder that I'll link to below and I'll keep adding

06:21

on to this as well. So with that, the only

06:23

other video in this module is going to be going

06:26

through 2 PIV loops. And now that we have a

06:28

lot of our system in place, everything besides validation that

06:31

we'll get into in the next module, we're just gonna

06:33

very simply prime, do it a v I planning, plan

06:36

our feature with our command, and then execute on it.

06:38

We're gonna do that twice just to show you how

06:41

smooth things are starting to look now that we have

06:44

all of our commands in place. And we're going to

06:46

iterate iterate, get more and more confident in our workflow

06:49

that we have for the PIV loop so that we

06:51

are ready to automate things more and more with strategies

06:54

like command chaining. That's what we'll get into in the

06:57

future modules. And then also throughout this process, I'll use

07:00

this just as a good time to talk about how

07:02

we can start to evolve our system. Any mistakes that

07:05

we see, we wanna think about, like, what should we

07:07

go back and change in our system? Should we update

07:10

our layer 1 planning, like our rules or on demand

07:12

context? Do we need to change something about our structured

07:15

plan template? I'll give some examples of that as well.